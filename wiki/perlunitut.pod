NAME
    perlunitut - Perl Unicode 指南

DESCRIPTION
    好的编程语言应该对多种字符编码有所支持。

    关于字符编码有很多内容，我们可能需要用一整天来学习，但是基本的知识却可以在几分钟内掌握。

    本篇文档包含关于编码最基本的知识。我们假设你知道不同编码存储结构不同等知识。

    This tutorial speaks in rather absolute terms, and provides only a
    limited view of the wealth of character string related features that
    Perl has to offer. For most projects, this information will probably
    suffice.

  一些定义
    It's important to set a few things straight first. This is the most
    important part of this tutorial. This view may conflict with other
    information that you may have found on the web, but that's mostly
    because many sources are wrong.

    You may have to re-read this entire section a few times...

   Unicode
    Unicode 是一种字符编码体系。

    There are many, many code points, but computers work with bytes, and a
    byte has room for only 256 values. Unicode has many more characters, so
    you need a method to make these accessible.

    Unicode 体系中有很多编码形式，UTF-8 是最常用的一种。

   UTF-8
    UTF-8 是 Unicode 编码体系中最常用的一种。许多人认为 Unicode 和 UTF-8 是相同的东西，但是它们却不是。

    UTF-8 treats the first 128 codepoints, 0..127, the same as ASCII. They
    take only one byte per character. All other characters are encoded as
    two or more (up to six) bytes using a complex scheme. Fortunately, Perl
    handles this for us, so we don't have to worry about this.

   文本字符串
    文本字符串是由字符构成的。字节和编码跟它都没有什么太大关系，字符就是字符而已。

    在一个文本字符串中，你可以这样做：

        $text =~ s/foo/bar/;
        if ($string =~ /^\d+$/) { ... }
        $text = ucfirst $text;
        my $character_count = length $text;

    "ord"、"chr" 可以将字符与 ASCII 编码之间进行转化。

   二进制字符串
    二进制字符串是由字节构成的。这里你将看不到任何字符，只有字节而已。所有对其的操作都是在二进制基础上完成的。

    对一个二进制字符串，你可以这么做：

        my (@length_content) = unpack "(V/a)*", $binary;
        $binary =~ s/\x00\x0F/\xFF\xF0/;  # for the brave :)
        print {$fh} $binary;
        my $byte_count = length $binary;

   编码
    编码是从文本字符串转化为二进制字符串。编码的时候你需要首先指定编码格式，如 "iso-8859-1" 或
    "UTF-8"。有一些编码并不支持所有的字符。

   解码
    解码是从二进制字符串转化为文本字符串。解码的时候你需要首先知道编码格式。否则无法正确解码。

   内置格式
    Perl 有内置格式。

    你不需要知道内置格式是什么，因为 Perl 会自动为你编码、解码。

  工具
    在你的代码开始处加入如下代码：

        use Encode qw(encode decode);

    或者偷懒的话，使用：

        use Encode;

  I/O 操作（真正的5分钟指南）
    输入输出流程如下：

        1. Receive and decode
        2. Process
        3. Encode and output

    如果你的输入为二进制字符串，而且想要得到的就是二进制字符串，那么你什么都不需要做。但是在我们的指南中，我们需要对其解码得到文本字符串。

    如果你不知道编码格式是什么的话，解码过程不一定会顺利完成。如果随便选一种的话，最好是标准的格式 UTF-8。

        my $foo   = decode('UTF-8', get 'http://example.com/');
        my $bar   = decode('ISO-8859-1', readline STDIN);
        my $xyzzy = decode('Windows-1251', $cgi->param('foo'));

    用 "substr"、"length" 等来处理数据。

    最后将处理好的数据编码成相应的编码格式。

    编码代码和解码代码一样简单，如下：

        $body = encode('UTF-8', $body);

    如果你想要知道该字符串占多少字节，现在才是查看的时候。因为 $body 现在是二进制字符串，你可以通过 "length" 方法得到它的长度。

        my $byte_count = length $body;

    And if the protocol you're using supports a way of letting the recipient
    know which character encoding you used, please help the receiving end by
    using that feature! For example, E-mail and HTTP support MIME headers,
    so you can use the "Content-Type" header. They can also have
    "Content-Length" to indicate the number of *bytes*, which is always a
    good idea to supply if the number is known.

        "Content-Type: text/plain; charset=UTF-8",
        "Content-Length: $byte_count"

总结
    获得输入后解码，发送输出前编码。

FAQ
    读完本篇文档，你应该再去读 perlunifaq。

鸣谢
    Thanks to Johan Vromans from Squirrel Consultancy. His UTF-8 rants
    during the Amsterdam Perl Mongers meetings got me interested and
    determined to find out how to use character encodings in Perl in ways
    that don't break easily.

    Thanks to Gerard Goossen from TTY. His presentation "UTF-8 in the wild"
    (Dutch Perl Workshop 2006) inspired me to publish my thoughts and write
    this tutorial.

    Thanks to the people who asked about this kind of stuff in several Perl
    IRC channels, and have constantly reminded me that a simpler explanation
    was needed.

    Thanks to the people who reviewed this document for me, before it went
    public. They are: Benjamin Smith, Jan-Pieter Cornet, Johan Vromans,
    Lukas Mai, Nathan Gray.

AUTHOR
    Juerd Waalboer <#####@juerd.nl>

    译者：xiaomo(wxm4ever@gmail.com)

另见
    perlunifaq, perlunicode, perluniintro, Encode

