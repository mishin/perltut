
        *****************************************************
        *           GENERATED FILE, DO NOT EDIT             * 
        * THIS IS NO SOURCE FILE, BUT RESULT OF COMPILATION *
        *****************************************************

This file was generated by po4a(7). Do not store it (in VCS, for example),
but store the PO file used as source file by po4a-translate. 

In fact, consider this as a binary, and the PO file as a regular .c file:
If the PO get lost, keeping this translation up-to-date will be harder.

=encoding UTF-8

=head1 NAME

perlreftut - 关于引用

=head1 DESCRIPTION

Perl 5
的一个特性就是你能够通过引用来操作复杂的数据结构，如多维数组、嵌套哈希等。要想熟练的使用引用需要学习大量的语法规则，手册中很详细的介绍了引用，但是我们很难分辨出哪些是有用的，所以很多人很难掌握这部分知识。

幸运的是，你只需要知道手册 10% 的知识就可以享受到引用 90% 的好处，所以这篇文档就是来介绍那 10% 部分。

=head1 谁需要使用复杂的数据结构？

在 Perl 4 的相当长的一段时间内，如何让哈希值指向列表是困扰大家的问题。当然，Perl 4 中也有哈希结构，但是哈希值只能是标量，不能指向列表。

为什么我们想要哈希值指向列表？下面看一个简单的例子。你有一些国家、城市的名字，如下：

	Chicago, USA
	Frankfurt, Germany
	Berlin, Germany
	Washington, USA
	Helsinki, Finland
	New York, USA

现在你想要如下的输出，每个国家只出现一次，国家后面跟着该国家的城市：

	Finland: Helsinki.
	Germany: Berlin, Frankfurt.
	USA:  Chicago, New York, Washington.

要想得到如上的功能，最自然的做法就是以国家为键存入哈希、对应城市放入列表存入相应键值中。之后根据对应的国家找到相应的城市列表，然后循环遍历即可。

如果哈希值不能指向列表的话，你就不能那么做了。此时你只能把所有的城市拼接成一个字符串，然后使用时需要分割之后再进行循环。这是不必要的，也是很浪费的。

=head1 解决方案

Perl 5 解决了这个困扰多时的问题，哈希值可以是标量，也可以是一个指向复杂结构的引用。

引用本质上也是一个标量，它I<指向>数组、哈希或是其他复杂的数据结构。

引用就像是数组、哈希的名字，通过它们，你可以清楚的指向正确的结构。

在 Perl 5 中，哈希值仍然不能是数组，哈希值只能是标量，只不过在 Perl 5 中我们有了引用。

接下来我们将回到 city-country 问题上，学习一些关于引用的语法。



=head1 语法

我们可以通过两种方式来创建引用，之后我们也可以通过两种方式来使用引用。

=head2 创建引用

=head3 B<Make Rule 1>

在变量前加 C<\> 你便可以得到指向该变量的引用。

    $aref = \@array;         # $aref now holds a reference to @array
    $href = \%hash;          # $href now holds a reference to %hash
    $sref = \$scalar;        # $sref now holds a reference to $scalar

用来存储引用的变量也可以想普通的标量值一样复制传递。

    $xy = $aref;             # $xy now holds a reference to @array
    $p[3] = $href;           # $p[3] now holds a reference to %hash
    $z = $p[3];              # $z now holds a reference to %hash



上面的例子讲解了如何创建引用。有时候我们需要创建匿名变量的引用时，也是类似的方法。

B<Make Rule 2>

C<[ ITEMS ]> 创建一个匿名数组并返回它的引用。C<{ ITEMS }> 创建一个匿名哈希并返回它的引用。

    $aref = [ 1, "foo", undef, 13 ];
    # $aref now holds a reference to an array

    $href = { APR => 4, AUG => 8 };
    # $href now holds a reference to a hash



方法二和方法一所创建的引用没有任何区别。

	# This:
	$aref = [ 1, 2, 3 ];

	# Does the same as this:
	@array = (1, 2, 3);
	$aref = \@array;



在不需要给数组命名的情况下，方法二更加简练。

C<[]> 会得到一个空匿名数组的引用，同样，C<{}> 会得到一个空匿名哈希的引用。



=head2 使用引用

我们可以如何使用引用？引用是一个标量，我们可以像操作其他标量一样对它进行存取操作。一般的，我们有两种方式来使用引用：

=head3 B<Use Rule 1>

你可以在大括号内使用引用来代替引用所指向结构的名字，如 C<@{$aref}> 来表示 C<@array>。

下面是一些例子：

数组：



	@a		@{$aref}		An array
	reverse @a	reverse @{$aref}	Reverse the array
	$a[3]		${$aref}[3]		An element of the array
	$a[3] = 17;	${$aref}[3] = 17	Assigning an element



每一行的两个代码都是在做同样的事情。

使用指向哈希的引用也是I<基本相同>的：

	%h		%{$href}	      A hash
	keys %h		keys %{$href}	      Get the keys from the hash
	$h{'red'}	${$href}{'red'}	      An element of the hash
	$h{'red'} = 17	${$href}{'red'} = 17  Assigning an element

通过方法一你便知道如何使用引用了，你只需要简单的把结构的名字替换为 C<{$reference}>。下面将介绍如何通过引用来遍历该数据结构。

        for my $element (@array) {
           ...
        }

就按方法一所说的替换数组的名字为引用：

        for my $element (@{$aref}) {
           ...
        }

那么我该如何输出引用指向的哈希的值呢？

        for my $key (keys %hash) {
          print "$key => $hash{$key}\n";
        }

同样也是替换哈希名为相应的引用：

        for my $key (keys %{$href}) {
          print "$key => ${$href}{$key}\n";
        }

=head3 B<Use Rule 2>

我们通过 B<Use Rule 1> 便可以很好的使用引用了。但是很多情况下，我们只是通过引用来得到某一项的值，这种时候 B<Use Rule 1>
就显得有些笨重了，所以便有了方法二。

C<${$aref}[3]> 太笨重了，不过我们可以使用 C<< $aref->[3] >>。

C<${$href}{red}> 太笨重了，不过我们可以使用 C<< $href->{red} >>。

注意区别 C<@aref>、C<$aref>，C<$href{'red'}>、C<$href-E<gt>{'red'}>。

Similarly, C<< $href->{'red'} >> is part of the hash referred to by the
scalar variable C<$href>, perhaps even one with no name.  C<$href{'red'}> is
part of the deceptively named C<%href> hash.  It's easy to forget to leave
out the C<< -> >>, and if you do, you'll get bizarre results when your
program gets array and hash elements out of totally unexpected hashes and
arrays that weren't the ones you wanted to use.



=head2 示例

让我们看下面这个例子：

C<[1, 2, 3]> 创建一个匿名数组，包含 C<(1, 2, 3)> 并返回指向它的引用。

那么如下代码：

	@a = ( [1, 2, 3],
               [4, 5, 6],
	       [7, 8, 9]
             );

@a 是一个包含三个元素的数组，每一个元素是一个指向数组的引用。

C<$a[1]> 是其中的一个引用。它指向 C<(4, 5, 6)> 数组。根据 B<Use Rule 2> 我们便可以通过 C<<
$a[1]->[2] >> 来得到该数组中的第三个元素，所以 C<< $a[1]->[2] >> 是6。因此，我们可以通过 C<<
$a[ROW]->[COLUMN] >> 来得到相应的元素。

这样写看起来还是很笨重，不过我们还有另外一种缩写方法。

=head2 Arrow Rule

在 C<< $a[ROW]->[COLUMN] >> 中箭头是可以省略的。

我们可以用 C<$a[1][2]> 来代表 C<< $a[1]->[2] >>，也可以用 C<$a[0][1] = 23> 来代表 C<<
$a[0]->[1] = 23 >>。

现在它看起来就很像二维数组了。

现在你知道箭头有多么重要了吧。如果没有它们，我们便不得不这样写，C<${$a[1]}[2]>，而不能使用 C<$a[1][2]>
这种形式。对于三维数组来说，我们便不得不这样写，C<${${$x[2]}[3]}[5]>，而不是C<$x[2][3][5]>。

=head1 解决方案

下面是之前 city-country 问题的解决方案：

    1   my %table;

    2   while (<>) {
    3    chomp;
    4     my ($city, $country) = split /, /;
    5     $table{$country} = [] unless exists $table{$country};
    6     push @{$table{$country}}, $city;
    7   }

    8   foreach $country (sort keys %table) {
    9     print "$country: ";
   10     my @cities = @{$table{$country}};
   11     print join ', ', sort @cities;
   12     print ".\n";
   13	}



代码包含两部分，2---7 行用来构建结构并存入信息，8---13 行用来输出信息。存储结构就是下面这个样子：



           %table
        +-------+---+
        |       |   |   +-----------+--------+
        |Germany| *---->| Frankfurt | Berlin |
        |       |   |   +-----------+--------+
        +-------+---+
        |       |   |   +----------+
        |Finland| *---->| Helsinki |
        |       |   |   +----------+
        +-------+---+
        |       |   |   +---------+------------+----------+
        |  USA  | *---->| Chicago | Washington | New York |
        |       |   |   +---------+------------+----------+
        +-------+---+

接下来我们考虑下如何把这个结构输出。

    8   foreach $country (sort keys %table) {
    9     print "$country: ";
   10     my @cities = @{$table{$country}};
   11     print join ', ', sort @cities;
   12     print ".\n";
   13	}

C<%table> 是一个普通的哈希结构，我们从中取出数组并循环遍历各元素。代码中只有第10行对引用进行了操作。这里我们是按 B<Use Rule 1>
规则来使用引用，C<@{$table{$country}> 和如下代码功能类似：

	@cities = @array;

通过引用得到该数组后，我们便像操作普通数组一样进行 sort、join、print 操作了。

2---7 行代码用来创建结构并存入相应信息：

    2   while (<>) {
    3    chomp;
    4     my ($city, $country) = split /, /;
    5     $table{$country} = [] unless exists $table{$country};
    6     push @{$table{$country}}, $city;
    7   }

2---4 行我们得到国家名称和城市名称。第5行查看该国家是否在哈希键中存在。如果不存在则将相应的哈希值通过 C<[]> 初始化为空数组引用。

第6行代码把相应的城市名称放入相应的数组中，和下面的代码功能相同：

	push @array, $city;

except that the name C<array> has been replaced by the reference
C<{$table{$country}}>.  The C<push> adds a city name to the end of the
referred-to array.

第5行代码其实是不必要的，我们可以注释掉它。

    2   while (<>) {
    3    chomp;
    4     my ($city, $country) = split /, /;
    5   ####  $table{$country} = [] unless exists $table{$country};
    6     push @{$table{$country}}, $city;
    7   }

如果当前的 C<$country> 在 C<%table> 早已存在，那么注释掉第5行代码不会有什么不同。但如果有一个 C<$country> 值为
C<Greece>，但是在 C<%table> 并不存在，此时 Perl 会如何处理呢？

Perl 会自动帮你处理好一切，不存在该键，那么 Perl 会为你创建该键值。对该哈希值进行 C<push()> 操作，那么 Perl
会为你创建一个空的数组。

=head1 剩余的10%

我曾经承诺过学习10%的知识来得到90%的好处，这表示还有90%的知识你需要去学习。现在你对引用有了大概的了解，这时 L<perlref>
对你来说已经没什么太大问题了。

L<perlref> 中的一些重点：

=over 4

=item *

你可以通过引用来指向任何类型的变量，包含标量、函数，甚至是指向引用。

=item *

B<Use Rule 1> 中说过在保证不产生歧义的前提下，你可以省略掉大括号，用 C<@$aref> 来表示 C<@{$aref}>，用
C<$$aref[1]> 来表示 C<${$aref}[1]>。但是如果你想保持良好的习惯的话，我们建议你不要省略掉大括号。

=item *

引用不是简单的复制。

        $aref2 = $aref1;

你现在拥有两个指向同一数组的引用。如果你修改 C<< $aref1->[23] >>，C<< $aref2->[23] >> 也会同样因此改变。

要想复制一个拷贝，使用：

        $aref2 = [@{$aref1}];

这样会通过 C<[...]> 来创建一个匿名数组并返回其引用，该匿名数组通过 C<$aref1> 指向的数组进行初始化，也就是复制了一份该数组的拷贝。

同样的，你也可以通过如上方式创建一个匿名哈希：

        $href2 = {%{$href1}};

=item *

判断一个变量的值是否为引用，可以通过 C<ref> 函数来实现。是引用时返回 true。准确的说，当是一个指向哈希的引用时返回
C<HASH>，而当是一个指向数组的引用时返回 C<ARRAY>。

=item *

如果你像使用字符串那样使用引用的话，你将得到如下的字符串：

	ARRAY(0x80f5dec)   or    HASH(0x826afc0)

如果你曾经见过如上形式的字符串，你现在就应该知道这是由于错误的输出引用而造成的。

但是我们可以利用这一点，然后通过 C<eq> 操作来判断两个引用是否指向同一个位置。（C<==> 操作会相对快一些。）

=item *

你可以像使用引用那样使用字符串。这种方式被称为I<软引用>或I<符号引用>。通过 C<use strict 'refs'> 来禁用此特性。

=back

你或许应该阅读 L<perllol> 而不是 L<perlref>，在那里详细的讲解了多维数组等复杂数据结构。之后，你应该阅读 L<perldsc>
来得到更多关于复杂数据结构的知识。

=head1 总结

所有人都会用到复杂的数据结构，在 Perl
中你可以通过引用来方便的实现它们。正确的创建和使用引用有四个规则：两个用来创建引用、两个用来使用引用。一旦你能熟练使用这四个原则，你便可以熟练的操作引用。

=head1 鸣谢

Author: Mark Jason Dominus, Plover Systems (C<mjd-perl-ref+@plover.com>)

这篇文档最早出现在 I<The Perl Journal> (http://www.tpj.com/) volume 3, #2，并授权在此使用。

此文档最初的标题为 I<Understand References Today>。

=head2 贡献

Copyright 1998 The Perl Journal.

This documentation is free; you can redistribute it and/or modify it under
the same terms as Perl itself.

Irrespective of its distribution, all code examples in these files are
hereby placed into the public domain.  You are permitted and encouraged to
use this code in your own programs for fun or for profit as you see fit.  A
simple comment in the code giving credit would be courteous but is not
required.

=head1 Author

译者：xiaomo(wxm4ever@gmail.com)





