# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2012-01-27 12:26+0800\n"
"PO-Revision-Date: 2012-01-27 12:26+0800\n"
"Last-Translator: xiaomo <wxm4ever@gmail.com>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: =head1
#: perlxstut.pod:1
msgid "NAME"
msgstr "NAME"

#. type: textblock
#: perlxstut.pod:3
msgid "perlXStut - Tutorial for writing XSUBs"
msgstr "perlXStut - XSUB 指南"

#. type: =head1
#: perlxstut.pod:5
msgid "DESCRIPTION"
msgstr "DESCRIPTION"

#. type: textblock
#: perlxstut.pod:7
msgid "This tutorial will educate the reader on the steps involved in creating a Perl extension.  The reader is assumed to have access to L<perlguts>, L<perlapi> and L<perlxs>."
msgstr "本篇文档将教用户如何创建 Perl 拓展。"

#. type: textblock
#: perlxstut.pod:11
msgid "This tutorial starts with very simple examples and becomes more complex, with each new example adding new features.  Certain concepts may not be completely explained until later in the tutorial in order to slowly ease the reader into building extensions."
msgstr "本文档由一个简单的例子开始，然后逐渐添加新特性而变得复杂。有些概念一开始并不会展"
"开介绍，不过会在之后进行详细介绍。"

#. type: textblock
#: perlxstut.pod:16
msgid "This tutorial was written from a Unix point of view.  Where I know them to be otherwise different for other platforms (e.g. Win32), I will list them.  If you find something that was missed, please let me know."
msgstr "本文档是基于 Unix 平台的。有些平台差异的地方我会在文档中指出。如果漏掉了什么，请"
"让我知道并改正。"

#. type: =head1
#: perlxstut.pod:20
msgid "SPECIAL NOTES"
msgstr "特别说明"

#. type: =head2
#: perlxstut.pod:22
msgid "make"
msgstr "make"

#. type: textblock
#: perlxstut.pod:24
msgid "This tutorial assumes that the make program that Perl is configured to use is called C<make>.  Instead of running \"make\" in the examples that follow, you may have to substitute whatever make program Perl has been configured to use.  Running B<perl -V:make> should tell you what it is."
msgstr "本文档假设 Perl 配置中的 make program 是 C<make>。首先我们需要确定我们环境中的 "
"make program 是什么。通过 B<perl -V:make> 我们就可以知道了。"

#. type: =head2
#: perlxstut.pod:29
msgid "Version caveat"
msgstr "版本警告"

#. type: textblock
#: perlxstut.pod:31
msgid "When writing a Perl extension for general consumption, one should expect that the extension will be used with versions of Perl different from the version available on your machine.  Since you are reading this document, the version of Perl on your machine is probably 5.005 or later, but the users of your extension may have more ancient versions."
msgstr "当编写 Perl 拓展时，我们希望我们的拓展能够在有着不同版本 Perl 的机子上正确运行，"
"此刻你阅读本文档，说明着你机子上的版本为 5.005 或 5.005 以上的版本，但是其他用户机子上"
"的 Perl 版本可能会很旧。"

#. type: textblock
#: perlxstut.pod:37
msgid "To understand what kinds of incompatibilities one may expect, and in the rare case that the version of Perl on your machine is older than this document, see the section on \"Troubleshooting these Examples\" for more information."
msgstr "如果你环境中的 Perl 版本比本文档中的版本旧的话，请在 \"Troubleshooting these "
"Examples\" 中得到更多信息。"

#. type: textblock
#: perlxstut.pod:41
msgid "If your extension uses some features of Perl which are not available on older releases of Perl, your users would appreciate an early meaningful warning.  You would probably put this information into the F<README> file, but nowadays installation of extensions may be performed automatically, guided by F<CPAN.pm> module or other tools."
msgstr "如果你的拓展用到了一些旧版本不支持的特性的话，你的用户或许希望得到一些有意义的"
"警告。你可以把这些版本信息放在 F<README> 文件中，但是现在的拓展更多是依赖 F<CPAN.pm> "
"自动完成安装。"

#. type: textblock
#: perlxstut.pod:47
msgid "In MakeMaker-based installations, F<Makefile.PL> provides the earliest opportunity to perform version checks.  One can put something like this in F<Makefile.PL> for this purpose:"
msgstr "在基于 MakeMaker 安装中，F<Makefile.PL> 进行版本检查。我们也可以添加如下代码进行"
"版本检查："

#. type: verbatim
#: perlxstut.pod:51
#, no-wrap
msgid ""
"    eval { require 5.007 }\n"
"        or die <<EOD;\n"
"    ############\n"
"    ### This module uses frobnication framework which is not available before\n"
"    ### version 5.007 of Perl.  Upgrade your Perl before installing Kara::Mba.\n"
"    ############\n"
"    EOD\n"
"\n"
msgstr ""
"    eval { require 5.007 }\n"
"        or die <<EOD;\n"
"    ############\n"
"    ### This module uses frobnication framework which is not available before\n"
"    ### version 5.007 of Perl.  Upgrade your Perl before installing Kara::Mba.\n"
"    ############\n"
"    EOD\n"
"\n"

#. type: =head2
#: perlxstut.pod:59
msgid "Dynamic Loading versus Static Loading"
msgstr "动态加载与静态加载"

#. type: textblock
#: perlxstut.pod:61
msgid "It is commonly thought that if a system does not have the capability to dynamically load a library, you cannot build XSUBs.  This is incorrect.  You I<can> build them, but you must link the XSUBs subroutines with the rest of Perl, creating a new executable.  This situation is similar to Perl 4."
msgstr "很多人认为如果系统不支持动态加载的话，我们将不能创建 XSUBs。但这种认识是错误的。"
"我们I<可以>创建它们，但是我们必须链接到 Perl，这与 Perl 4 是非常相似的。"

#. type: textblock
#: perlxstut.pod:67
msgid "This tutorial can still be used on such a system.  The XSUB build mechanism will check the system and build a dynamically-loadable library if possible, or else a static library and then, optionally, a new statically-linked executable with that static library linked in."
msgstr "我们的文档当然也可以运行在那样的系统上。XSUB 会检查系统是否支持动态加载，不能的话"
"就使用静态加载并自动完成一些相对复杂的功能。"

#. type: textblock
#: perlxstut.pod:72
msgid "Should you wish to build a statically-linked executable on a system which can dynamically load libraries, you may, in all the following examples, where the command \"C<make>\" with no arguments is executed, run the command \"C<make perl>\" instead."
msgstr "有时候我们也想在一个支持动态加载的系统上来创建静态加载的拓展。所以我们在下面的例"
"子中执行 \"C<make perl>\" 而不是 \"C<make>\"。"

#. type: textblock
#: perlxstut.pod:77
msgid "If you have generated such a statically-linked executable by choice, then instead of saying \"C<make test>\", you should say \"C<make test_static>\".  On systems that cannot build dynamically-loadable libraries at all, simply saying \"C<make test>\" is sufficient."
msgstr "而且你应该执行\"C<make test_static>\" 而不是 \"C<make test>\"。在不支持动态加载的"
"系统上运行 \"C<make test>\" 就可以了。"

#. type: =head1
#: perlxstut.pod:82
msgid "TUTORIAL"
msgstr "指南"

#. type: textblock
#: perlxstut.pod:84
msgid "Now let's go on with the show!"
msgstr "现在让我们开始学习 XSUB"

#. type: =head2
#: perlxstut.pod:86
msgid "EXAMPLE 1"
msgstr "EXAMPLE 1"

#. type: textblock
#: perlxstut.pod:88
msgid "Our first extension will be very simple.  When we call the routine in the extension, it will print out a well-known message and return."
msgstr "我们的第一个拓展会非常简单。当我们调用拓展中的方法时，会输出一条信息。"

#. type: textblock
#: perlxstut.pod:91
msgid "Run \"C<h2xs -A -n Mytest>\".  This creates a directory named Mytest, possibly under ext/ if that directory exists in the current working directory.  Several files will be created under the Mytest dir, including MANIFEST, Makefile.PL, lib/Mytest.pm, Mytest.xs, t/Mytest.t, and Changes."
msgstr "执行 \"C<h2xs -A -n Mytest>\"。这将会生成一个 Mytest 目录，如果当前目录中存在 "
"ext/ 目录的话将会包含在它里面。目录中包含一些文件，如 MANIFEST、Makefile.PL、"
"lib/Mytest.pm、Mytest.xs、t/Mytest.t、Changes 等。"

#. type: textblock
#: perlxstut.pod:96
msgid "The MANIFEST file contains the names of all the files just created in the Mytest directory."
msgstr "MANIFEST 文件包含 Mytest 文件下所有文件的名字。"

#. type: textblock
#: perlxstut.pod:99
msgid "The file Makefile.PL should look something like this:"
msgstr "Makefile.PL 文件看起来是这个样子："

#. type: verbatim
#: perlxstut.pod:101
#, no-wrap
msgid ""
"    use ExtUtils::MakeMaker;\n"
"    # See lib/ExtUtils/MakeMaker.pm for details of how to influence\n"
"    # the contents of the Makefile that is written.\n"
"    WriteMakefile(\n"
"\tNAME         => 'Mytest',\n"
"\tVERSION_FROM => 'Mytest.pm', # finds $VERSION\n"
"\tLIBS         => [''],   # e.g., '-lm'\n"
"\tDEFINE       => '',     # e.g., '-DHAVE_SOMETHING'\n"
"\tINC          => '',     # e.g., '-I/usr/include/other'\n"
"    );\n"
"\n"
msgstr ""
"    use ExtUtils::MakeMaker;\n"
"    # See lib/ExtUtils/MakeMaker.pm for details of how to influence\n"
"    # the contents of the Makefile that is written.\n"
"    WriteMakefile(\n"
"\tNAME         => 'Mytest',\n"
"\tVERSION_FROM => 'Mytest.pm', # finds $VERSION\n"
"\tLIBS         => [''],   # e.g., '-lm'\n"
"\tDEFINE       => '',     # e.g., '-DHAVE_SOMETHING'\n"
"\tINC          => '',     # e.g., '-I/usr/include/other'\n"
"    );\n"
"\n"

#. type: textblock
#: perlxstut.pod:112
msgid "The file Mytest.pm should start with something like this:"
msgstr "Mytest.pm 文件由如下代码开始："

#. type: verbatim
#: perlxstut.pod:114
#, no-wrap
msgid ""
"    package Mytest;\n"
"\n"
msgstr ""
"    package Mytest;\n"
"\n"

#. type: verbatim
#: perlxstut.pod:116
#, no-wrap
msgid ""
"    use 5.008008;\n"
"    use strict;\n"
"    use warnings;\n"
"\n"
msgstr ""
"    use 5.008008;\n"
"    use strict;\n"
"    use warnings;\n"
"\n"

#. type: verbatim
#: perlxstut.pod:120
#, no-wrap
msgid ""
"    require Exporter;\n"
"\n"
msgstr ""
"    require Exporter;\n"
"\n"

#. type: verbatim
#: perlxstut.pod:122
#, no-wrap
msgid ""
"    our @ISA = qw(Exporter);\n"
"    our %EXPORT_TAGS = ( 'all' => [ qw(\n"
"\n"
msgstr ""
"    our @ISA = qw(Exporter);\n"
"    our %EXPORT_TAGS = ( 'all' => [ qw(\n"
"\n"

#. type: verbatim
#: perlxstut.pod:125
#, no-wrap
msgid ""
"    ) ] );\n"
"\n"
msgstr ""
"    ) ] );\n"
"\n"

#. type: verbatim
#: perlxstut.pod:127
#, no-wrap
msgid ""
"    our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );\n"
"\n"
msgstr ""
"    our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );\n"
"\n"

#. type: verbatim
#: perlxstut.pod:129
#, no-wrap
msgid ""
"    our @EXPORT = qw(\n"
"\n"
msgstr ""
"    our @EXPORT = qw(\n"
"\n"

#. type: verbatim
#: perlxstut.pod:131
#, no-wrap
msgid ""
"    );\n"
"\n"
msgstr ""
"    );\n"
"\n"

#. type: verbatim
#: perlxstut.pod:133
#, no-wrap
msgid ""
"    our $VERSION = '0.01';\n"
"\n"
msgstr ""
"    our $VERSION = '0.01';\n"
"\n"

#. type: verbatim
#: perlxstut.pod:135
#, no-wrap
msgid ""
"    require XSLoader;\n"
"    XSLoader::load('Mytest', $VERSION);\n"
"\n"
msgstr ""
"    require XSLoader;\n"
"    XSLoader::load('Mytest', $VERSION);\n"
"\n"

#. type: verbatim
#: perlxstut.pod:138
#, no-wrap
msgid ""
"    # Preloaded methods go here.\n"
"\n"
msgstr ""
"    # Preloaded methods go here.\n"
"\n"

#. type: verbatim
#: perlxstut.pod:140
#, no-wrap
msgid ""
"    1;\n"
"    __END__\n"
"    # Below is the stub of documentation for your module. You better edit it!\n"
"\n"
msgstr ""
"    1;\n"
"    __END__\n"
"    # Below is the stub of documentation for your module. You better edit it!\n"
"\n"

#. type: textblock
#: perlxstut.pod:144
msgid "The rest of the .pm file contains sample code for providing documentation for the extension."
msgstr "该文件剩余的部分包含一些拓展的示例文档。"

#. type: textblock
#: perlxstut.pod:147
msgid "Finally, the Mytest.xs file should look something like this:"
msgstr "Mytest.xs 文件是这样："

#. type: verbatim
#: perlxstut.pod:149
#, no-wrap
msgid ""
"    #include \"EXTERN.h\"\n"
"    #include \"perl.h\"\n"
"    #include \"XSUB.h\"\n"
"\n"
msgstr ""
"    #include \"EXTERN.h\"\n"
"    #include \"perl.h\"\n"
"    #include \"XSUB.h\"\n"
"\n"

#. type: verbatim
#: perlxstut.pod:153
#, no-wrap
msgid ""
"    #include \"ppport.h\"\n"
"\n"
msgstr ""
"    #include \"ppport.h\"\n"
"\n"

#. type: verbatim
#: perlxstut.pod:155
#, no-wrap
msgid ""
"    MODULE = Mytest\t\tPACKAGE = Mytest\n"
"\n"
msgstr ""
"    MODULE = Mytest\t\tPACKAGE = Mytest\n"
"\n"

#. type: textblock
#: perlxstut.pod:157
msgid "Let's edit the .xs file by adding this to the end of the file:"
msgstr "现在我们在 .xs 文件后面添加："

#. type: verbatim
#: perlxstut.pod:159
#, no-wrap
msgid ""
"    void\n"
"    hello()\n"
"\tCODE:\n"
"\t    printf(\"Hello, world!\\n"
"\");\n"
"\n"
msgstr ""
"    void\n"
"    hello()\n"
"\tCODE:\n"
"\t    printf(\"Hello, world!\\n"
"\");\n"
"\n"

#. type: textblock
#: perlxstut.pod:164
msgid "It is okay for the lines starting at the \"CODE:\" line to not be indented.  However, for readability purposes, it is suggested that you indent CODE: one level and the lines following one more level."
msgstr "\"CODE:\" 行即使不缩进也没有关系，不过我们推荐将其缩进。"

#. type: textblock
#: perlxstut.pod:168
msgid "Now we'll run \"C<perl Makefile.PL>\".  This will create a real Makefile, which make needs.  Its output looks something like:"
msgstr "现在我们执行\"C<perl Makefile.PL>\"。这将生成一个 make 操作需要的 Makefile 文件。 "
"这个过程的输出如下："

#. type: verbatim
#: perlxstut.pod:171
#, no-wrap
msgid ""
"    % perl Makefile.PL\n"
"    Checking if your kit is complete...\n"
"    Looks good\n"
"    Writing Makefile for Mytest\n"
"    %\n"
"\n"
msgstr ""
"    % perl Makefile.PL\n"
"    Checking if your kit is complete...\n"
"    Looks good\n"
"    Writing Makefile for Mytest\n"
"    %\n"
"\n"

#. type: textblock
#: perlxstut.pod:177
msgid "Now, running make will produce output that looks something like this (some long lines have been shortened for clarity and some extraneous lines have been deleted):"
msgstr "现在执行 make 将会输出："

#. type: verbatim
#: perlxstut.pod:181
#, no-wrap
msgid ""
"    % make\n"
"    cp lib/Mytest.pm blib/lib/Mytest.pm\n"
"    perl xsubpp  -typemap typemap  Mytest.xs > Mytest.xsc && mv Mytest.xsc Mytest.c\n"
"    Please specify prototyping behavior for Mytest.xs (see perlxs manual)\n"
"    cc -c     Mytest.c\n"
"    Running Mkbootstrap for Mytest ()\n"
"    chmod 644 Mytest.bs\n"
"    rm -f blib/arch/auto/Mytest/Mytest.so\n"
"    cc  -shared -L/usr/local/lib Mytest.o  -o blib/arch/auto/Mytest/Mytest.so   \\\n"
"                \\\n"
"\n"
msgstr ""
"    % make\n"
"    cp lib/Mytest.pm blib/lib/Mytest.pm\n"
"    perl xsubpp  -typemap typemap  Mytest.xs > Mytest.xsc && mv Mytest.xsc Mytest.c\n"
"    Please specify prototyping behavior for Mytest.xs (see perlxs manual)\n"
"    cc -c     Mytest.c\n"
"    Running Mkbootstrap for Mytest ()\n"
"    chmod 644 Mytest.bs\n"
"    rm -f blib/arch/auto/Mytest/Mytest.so\n"
"    cc  -shared -L/usr/local/lib Mytest.o  -o blib/arch/auto/Mytest/Mytest.so   \\\n"
"                \\\n"
"\n"

#. type: verbatim
#: perlxstut.pod:192
#, no-wrap
msgid ""
"    chmod 755 blib/arch/auto/Mytest/Mytest.so\n"
"    cp Mytest.bs blib/arch/auto/Mytest/Mytest.bs\n"
"    chmod 644 blib/arch/auto/Mytest/Mytest.bs\n"
"    Manifying blib/man3/Mytest.3pm\n"
"    %\n"
"\n"
msgstr ""
"    chmod 755 blib/arch/auto/Mytest/Mytest.so\n"
"    cp Mytest.bs blib/arch/auto/Mytest/Mytest.bs\n"
"    chmod 644 blib/arch/auto/Mytest/Mytest.bs\n"
"    Manifying blib/man3/Mytest.3pm\n"
"    %\n"
"\n"

#. type: textblock
#: perlxstut.pod:198
msgid "You can safely ignore the line about \"prototyping behavior\" - it is explained in L<perlxs/\"The PROTOTYPES: Keyword\">."
msgstr "你可以忽略掉 \"prototyping behavior\" 这一行 - 这会在 L<perlxs/\"The PROTOTYPES: "
"Keyword\"> 中解释。"

#. type: textblock
#: perlxstut.pod:201
msgid "If you are on a Win32 system, and the build process fails with linker errors for functions in the C library, check if your Perl is configured to use PerlCRT (running B<perl -V:libc> should show you if this is the case).  If Perl is configured to use PerlCRT, you have to make sure PerlCRT.lib is copied to the same location that msvcrt.lib lives in, so that the compiler can find it on its own.  msvcrt.lib is usually found in the Visual C compiler's lib directory (e.g. C:/DevStudio/VC/lib)."
msgstr ""

#. type: textblock
#: perlxstut.pod:209
msgid "Perl has its own special way of easily writing test scripts, but for this example only, we'll create our own test script.  Create a file called hello that looks like this:"
msgstr "Perl 有自己的方法来写测试脚本，但在这个例子中，我们来自己写测试脚本。创建一个名"
"叫 hello 的文件："

#. type: verbatim
#: perlxstut.pod:213
#, no-wrap
msgid ""
"    #! /opt/perl5/bin/perl\n"
"\n"
msgstr ""
"    #! /opt/perl5/bin/perl\n"
"\n"

#. type: verbatim
#: perlxstut.pod:215
#, no-wrap
msgid ""
"    use ExtUtils::testlib;\n"
"\n"
msgstr ""
"    use ExtUtils::testlib;\n"
"\n"

#. type: verbatim
#: perlxstut.pod:217
#, no-wrap
msgid ""
"    use Mytest;\n"
"\n"
msgstr ""
"    use Mytest;\n"
"\n"

#. type: verbatim
#: perlxstut.pod:219
#, no-wrap
msgid ""
"    Mytest::hello();\n"
"\n"
msgstr ""
"    Mytest::hello();\n"
"\n"

#. type: textblock
#: perlxstut.pod:221
msgid "Now we make the script executable (C<chmod +x hello>), run the script and we should see the following output:"
msgstr "现在我们使脚本可执行（C<chmod +x hello>），然后执行该脚本得到输出："

#. type: verbatim
#: perlxstut.pod:224
#, no-wrap
msgid ""
"    % ./hello\n"
"    Hello, world!\n"
"    %\n"
"\n"
msgstr ""
"    % ./hello\n"
"    Hello, world!\n"
"    %\n"
"\n"

#. type: =head2
#: perlxstut.pod:228
msgid "EXAMPLE 2"
msgstr "EXAMPLE 2"

#. type: textblock
#: perlxstut.pod:230
msgid "Now let's add to our extension a subroutine that will take a single numeric argument as input and return 0 if the number is even or 1 if the number is odd."
msgstr "现在为我们的拓展添加一个接受整数为参数并进行判断奇偶性的函数。"

#. type: textblock
#: perlxstut.pod:234
#: perlxstut.pod:363
msgid "Add the following to the end of Mytest.xs:"
msgstr "在 Mytest.xs 末尾添加："

#. type: verbatim
#: perlxstut.pod:236
#, no-wrap
msgid ""
"    int\n"
"    is_even(input)\n"
"\t    int input\n"
"\tCODE:\n"
"\t    RETVAL = (input % 2 == 0);\n"
"\tOUTPUT:\n"
"\t    RETVAL\n"
"\n"
msgstr ""
"    int\n"
"    is_even(input)\n"
"\t    int input\n"
"\tCODE:\n"
"\t    RETVAL = (input % 2 == 0);\n"
"\tOUTPUT:\n"
"\t    RETVAL\n"
"\n"

#. type: textblock
#: perlxstut.pod:244
msgid "There does not need to be whitespace at the start of the \"C<int input>\" line, but it is useful for improving readability.  Placing a semi-colon at the end of that line is also optional.  Any amount and kind of whitespace may be placed between the \"C<int>\" and \"C<input>\"."
msgstr "在 \"C<int input>\" 前面的空格是不必要的，不过我们推荐这么做来使得代码更加可读。"
"在每行的结尾加分号也是可选的。"

#. type: textblock
#: perlxstut.pod:249
msgid "Now re-run make to rebuild our new shared library."
msgstr "现在我们重新执行一次上述的过程。"

#. type: textblock
#: perlxstut.pod:251
msgid "Now perform the same steps as before, generating a Makefile from the Makefile.PL file, and running make."
msgstr "和之前一样，我们先从 Makefile.PL 生成 Makefile，然后执行 make。"

#. type: textblock
#: perlxstut.pod:254
msgid "In order to test that our extension works, we now need to look at the file Mytest.t.  This file is set up to imitate the same kind of testing structure that Perl itself has.  Within the test script, you perform a number of tests to confirm the behavior of the extension, printing \"ok\" when the test is correct, \"not ok\" when it is not."
msgstr "为了测试我们的拓展，我们在 Mytest.t 中加入一些测试代码。"

#. type: verbatim
#: perlxstut.pod:260
#, no-wrap
msgid ""
"    use Test::More tests => 4;\n"
"    BEGIN { use_ok('Mytest') };\n"
"\n"
msgstr ""
"    use Test::More tests => 4;\n"
"    BEGIN { use_ok('Mytest') };\n"
"\n"

#. type: verbatim
#: perlxstut.pod:263
#, no-wrap
msgid ""
"    #########################\n"
"\n"
msgstr ""
"    #########################\n"
"\n"

#. type: verbatim
#: perlxstut.pod:265
#, no-wrap
msgid ""
"    # Insert your test code below, the Test::More module is use()ed here so read\n"
"    # its man page ( perldoc Test::More ) for help writing this test script.\n"
"\n"
msgstr ""
"    # Insert your test code below, the Test::More module is use()ed here so read\n"
"    # its man page ( perldoc Test::More ) for help writing this test script.\n"
"\n"

#. type: verbatim
#: perlxstut.pod:268
#, no-wrap
msgid ""
"    is(&Mytest::is_even(0), 1);\n"
"    is(&Mytest::is_even(1), 0);\n"
"    is(&Mytest::is_even(2), 1);\n"
"\n"
msgstr ""
"    is(&Mytest::is_even(0), 1);\n"
"    is(&Mytest::is_even(1), 0);\n"
"    is(&Mytest::is_even(2), 1);\n"
"\n"

#. type: textblock
#: perlxstut.pod:272
msgid "We will be calling the test script through the command \"C<make test>\".  You should see output that looks something like this:"
msgstr "我们可以通过执行 \"C<make test>\" 来进行测试。我们将会看到如下输出："

#. type: verbatim
#: perlxstut.pod:275
#, no-wrap
msgid ""
"    %make test\n"
"    PERL_DL_NONLAZY=1 /usr/bin/perl \"-MExtUtils::Command::MM\" \"-e\" \"test_harness(0, 'blib/lib', 'blib/arch')\" t/*.t\n"
"    t/Mytest....ok\n"
"    All tests successful.\n"
"    Files=1, Tests=4,  0 wallclock secs ( 0.03 cusr +  0.00 csys =  0.03 CPU)\n"
"    %\n"
"\n"
msgstr ""
"    %make test\n"
"    PERL_DL_NONLAZY=1 /usr/bin/perl \"-MExtUtils::Command::MM\" \"-e\" \"test_harness(0, 'blib/lib', 'blib/arch')\" t/*.t\n"
"    t/Mytest....ok\n"
"    All tests successful.\n"
"    Files=1, Tests=4,  0 wallclock secs ( 0.03 cusr +  0.00 csys =  0.03 CPU)\n"
"    %\n"
"\n"

#. type: =head2
#: perlxstut.pod:282
msgid "What has gone on?"
msgstr "发生了什么？"

#. type: textblock
#: perlxstut.pod:284
msgid "The program h2xs is the starting point for creating extensions.  In later examples we'll see how we can use h2xs to read header files and generate templates to connect to C routines."
msgstr "我们通过 h2xs 来创建拓展。在后面的例子中我们将看到 h2xs 是如何读取头文件然后生成"
"相应的文件。"

#. type: textblock
#: perlxstut.pod:288
msgid "h2xs creates a number of files in the extension directory.  The file Makefile.PL is a perl script which will generate a true Makefile to build the extension.  We'll take a closer look at it later."
msgstr "h2xs 在拓展目录内创建了一些文件。Makefile.PL 是一个 Perl 脚本，我们将会在后面仔细"
"的研究它。"

#. type: textblock
#: perlxstut.pod:292
msgid "The .pm and .xs files contain the meat of the extension.  The .xs file holds the C routines that make up the extension.  The .pm file contains routines that tell Perl how to load your extension."
msgstr ".pm 和 .xs 文件是拓展的主要部分。.xs 文件包含拓展的 C 语言部分，.pm 文件告诉 "
"Perl 如何加载你的拓展。"

#. type: textblock
#: perlxstut.pod:296
msgid "Generating the Makefile and running C<make> created a directory called blib (which stands for \"build library\") in the current working directory.  This directory will contain the shared library that we will build.  Once we have tested it, we can install it into its final location."
msgstr "生成 Makefile 然后执行 C<make> 命令会创建一个 blib 目录。这个目录中包含创建好的"
"共享库。一旦我们测试好它，便可以正式使用。"

#. type: textblock
#: perlxstut.pod:301
msgid "Invoking the test script via \"C<make test>\" did something very important.  It invoked perl with all those C<-I> arguments so that it could find the various files that are part of the extension.  It is I<very> important that while you are still testing extensions that you use \"C<make test>\".  If you try to run the test script all by itself, you will get a fatal error.  Another reason it is important to use \"C<make test>\" to run your test script is that if you are testing an upgrade to an already-existing version, using \"C<make test>\" ensures that you will test your new extension, not the already-existing version."
msgstr "通过 \"<make test>\" 来执行测试。"

#. type: textblock
#: perlxstut.pod:311
msgid "When Perl sees a C<use extension;>, it searches for a file with the same name as the C<use>'d extension that has a .pm suffix.  If that file cannot be found, Perl dies with a fatal error.  The default search path is contained in the C<@INC> array."
msgstr ""

#. type: textblock
#: perlxstut.pod:316
msgid "In our case, Mytest.pm tells perl that it will need the Exporter and Dynamic Loader extensions.  It then sets the C<@ISA> and C<@EXPORT> arrays and the C<$VERSION> scalar; finally it tells perl to bootstrap the module.  Perl will call its dynamic loader routine (if there is one) and load the shared library."
msgstr "这个例子中，Mytest.pm 会告诉 perl 它将需要 Exporter 和 动态加载。它会设置好 "
"C<@ISA>、C<@EXPORT>、C<$VERSION> 等变量，然后 perl 会加载模块。"

#. type: textblock
#: perlxstut.pod:322
msgid "The two arrays C<@ISA> and C<@EXPORT> are very important.  The C<@ISA> array contains a list of other packages in which to search for methods (or subroutines) that do not exist in the current package.  This is usually only important for object-oriented extensions (which we will talk about much later), and so usually doesn't need to be modified."
msgstr "C<@ISA>、C<@EXPORT> 是非常重要的两个东西。C<@ISA> 包含 perl 寻找方法的包名。"

#. type: textblock
#: perlxstut.pod:328
msgid "The C<@EXPORT> array tells Perl which of the extension's variables and subroutines should be placed into the calling package's namespace.  Because you don't know if the user has already used your variable and subroutine names, it's vitally important to carefully select what to export.  Do I<not> export method or variable names I<by default> without a good reason."
msgstr "C<@EXPORT> 数组告诉 Perl 导出哪些变量和方法。最好I<不要>无理由的I<默认>导出一些"
"变量或方法。"

#. type: textblock
#: perlxstut.pod:334
msgid "As a general rule, if the module is trying to be object-oriented then don't export anything.  If it's just a collection of functions and variables, then you can export them via another array, called C<@EXPORT_OK>.  This array does not automatically place its subroutine and variable names into the namespace unless the user specifically requests that this be done."
msgstr "如果模块是一系列变量与函数的集合，那么我们可以通过另外一种方式 C<@EXPORT_OK> 来"
"导出。这种方式不会自动导入，它需要显示声明要导入的变量与函数。"

#. type: textblock
#: perlxstut.pod:340
msgid "See L<perlmod> for more information."
msgstr "请参看 L<perlmod> 查看更多信息。"

#. type: textblock
#: perlxstut.pod:342
msgid "The C<$VERSION> variable is used to ensure that the .pm file and the shared library are \"in sync\" with each other.  Any time you make changes to the .pm or .xs files, you should increment the value of this variable."
msgstr "C<$VERSION> 变量用来保证 .pm 文件能够正确的运行。每当你改变 .pm 或 .xs 文件时，你"
"也需要相应的更改该变量。"

#. type: =head2
#: perlxstut.pod:346
msgid "Writing good test scripts"
msgstr "编写好的测试脚本"

#. type: textblock
#: perlxstut.pod:348
msgid "The importance of writing good test scripts cannot be over-emphasized.  You should closely follow the \"ok/not ok\" style that Perl itself uses, so that it is very easy and unambiguous to determine the outcome of each test case.  When you find and fix a bug, make sure you add a test case for it."
msgstr "编写测试脚本的重要再怎么强调也不未过。你只需要简单的进行 \"ok/not ok\" 测试，然后"
"发现相应的 bug 并改正。"

#. type: textblock
#: perlxstut.pod:353
msgid "By running \"C<make test>\", you ensure that your Mytest.t script runs and uses the correct version of your extension.  If you have many test cases, save your test files in the \"t\" directory and use the suffix \".t\".  When you run \"C<make test>\", all of these test files will be executed."
msgstr "通过执行 \"C<make test>\"，所有在 \"t\" 目录下的以 \".t\" 为后缀名的文件都会被测"
"试。"

#. type: =head2
#: perlxstut.pod:358
msgid "EXAMPLE 3"
msgstr "EXAMPLE 3"

#. type: textblock
#: perlxstut.pod:360
msgid "Our third extension will take one argument as its input, round off that value, and set the I<argument> to the rounded value."
msgstr "我们的第三个例子会接受一个参数，然后进行四舍五入操作。"

#. type: verbatim
#: perlxstut.pod:365
#, no-wrap
msgid ""
"\tvoid\n"
"\tround(arg)\n"
"\t\tdouble  arg\n"
"\t    CODE:\n"
"\t\tif (arg > 0.0) {\n"
"\t\t\targ = floor(arg + 0.5);\n"
"\t\t} else if (arg < 0.0) {\n"
"\t\t\targ = ceil(arg - 0.5);\n"
"\t\t} else {\n"
"\t\t\targ = 0.0;\n"
"\t\t}\n"
"\t    OUTPUT:\n"
"\t\targ\n"
"\n"
msgstr ""
"\tvoid\n"
"\tround(arg)\n"
"\t\tdouble  arg\n"
"\t    CODE:\n"
"\t\tif (arg > 0.0) {\n"
"\t\t\targ = floor(arg + 0.5);\n"
"\t\t} else if (arg < 0.0) {\n"
"\t\t\targ = ceil(arg - 0.5);\n"
"\t\t} else {\n"
"\t\t\targ = 0.0;\n"
"\t\t}\n"
"\t    OUTPUT:\n"
"\t\targ\n"
"\n"

#. type: textblock
#: perlxstut.pod:379
msgid "Edit the Makefile.PL file so that the corresponding line looks like this:"
msgstr "修改 Makefile.PL 文件："

#. type: verbatim
#: perlxstut.pod:381
#, no-wrap
msgid ""
"\t'LIBS'      => ['-lm'],   # e.g., '-lm'\n"
"\n"
msgstr ""
"\t'LIBS'      => ['-lm'],   # e.g., '-lm'\n"
"\n"

#. type: textblock
#: perlxstut.pod:383
msgid "Generate the Makefile and run make.  Change the test number in Mytest.t to \"9\" and add the following tests:"
msgstr "生成 makefile 并执行 make 命令。修改 test number 为 9 并且添加如下测试："

#. type: verbatim
#: perlxstut.pod:386
#, no-wrap
msgid ""
"\t$i = -1.5; &Mytest::round($i); is( $i, -2.0 );\n"
"\t$i = -1.1; &Mytest::round($i); is( $i, -1.0 );\n"
"\t$i = 0.0; &Mytest::round($i);  is( $i,  0.0 );\n"
"\t$i = 0.5; &Mytest::round($i);  is( $i,  1.0 );\n"
"\t$i = 1.2; &Mytest::round($i);  is( $i,  1.0 );\n"
"\n"
msgstr ""
"\t$i = -1.5; &Mytest::round($i); is( $i, -2.0 );\n"
"\t$i = -1.1; &Mytest::round($i); is( $i, -1.0 );\n"
"\t$i = 0.0; &Mytest::round($i);  is( $i,  0.0 );\n"
"\t$i = 0.5; &Mytest::round($i);  is( $i,  1.0 );\n"
"\t$i = 1.2; &Mytest::round($i);  is( $i,  1.0 );\n"
"\n"

#. type: textblock
#: perlxstut.pod:392
msgid "Running \"C<make test>\" should now print out that all nine tests are okay."
msgstr "执行 \"C<make test>\" 将得到所有测试均正常。"

#. type: textblock
#: perlxstut.pod:394
msgid "Notice that in these new test cases, the argument passed to round was a scalar variable.  You might be wondering if you can round a constant or literal.  To see what happens, temporarily add the following line to Mytest.t:"
msgstr "注意这里我们传递变量进去。想要看看传递标量进去会发生什么吗？添加如下测试："

#. type: verbatim
#: perlxstut.pod:398
#, no-wrap
msgid ""
"\t&Mytest::round(3);\n"
"\n"
msgstr ""
"\t&Mytest::round(3);\n"
"\n"

#. type: textblock
#: perlxstut.pod:400
msgid "Run \"C<make test>\" and notice that Perl dies with a fatal error.  Perl won't let you change the value of constants!"
msgstr "执行 \"C<make test>\" 后将会得到一个错误。Perl 不允许你改变标量的值。"

#. type: =head2
#: perlxstut.pod:403
msgid "What's new here?"
msgstr "What's new here?"

#. type: =item
#: perlxstut.pod:407
#: perlxstut.pod:414
#: perlxstut.pod:648
#: perlxstut.pod:654
#: perlxstut.pod:662
#: perlxstut.pod:671
#: perlxstut.pod:676
#: perlxstut.pod:1012
#: perlxstut.pod:1021
#: perlxstut.pod:1034
#: perlxstut.pod:1047
#: perlxstut.pod:1055
#: perlxstut.pod:1145
#: perlxstut.pod:1153
#: perlxstut.pod:1165
#: perlxstut.pod:1187
#: perlxstut.pod:1195
#: perlxstut.pod:1204
#: perlxstut.pod:1328
#: perlxstut.pod:1336
#: perlxstut.pod:1345
#: perlxstut.pod:1352
msgid "*"
msgstr "*"

#. type: textblock
#: perlxstut.pod:409
msgid "We've made some changes to Makefile.PL.  In this case, we've specified an extra library to be linked into the extension's shared library, the math library libm in this case.  We'll talk later about how to write XSUBs that can call every routine in a library."
msgstr ""

#. type: textblock
#: perlxstut.pod:416
msgid "The value of the function is not being passed back as the function's return value, but by changing the value of the variable that was passed into the function.  You might have guessed that when you saw that the return value of round is of type \"void\"."
msgstr ""

#. type: =head2
#: perlxstut.pod:423
msgid "Input and Output Parameters"
msgstr ""

#. type: textblock
#: perlxstut.pod:425
msgid "You specify the parameters that will be passed into the XSUB on the line(s)  after you declare the function's return value and name.  Each input parameter line starts with optional whitespace, and may have an optional terminating semicolon."
msgstr ""

#. type: textblock
#: perlxstut.pod:430
msgid "The list of output parameters occurs at the very end of the function, just after the OUTPUT: directive.  The use of RETVAL tells Perl that you wish to send this value back as the return value of the XSUB function.  In Example 3, we wanted the \"return value\" placed in the original variable which we passed in, so we listed it (and not RETVAL) in the OUTPUT: section."
msgstr ""

#. type: =head2
#: perlxstut.pod:436
msgid "The XSUBPP Program"
msgstr ""

#. type: textblock
#: perlxstut.pod:438
msgid "The B<xsubpp> program takes the XS code in the .xs file and translates it into C code, placing it in a file whose suffix is .c.  The C code created makes heavy use of the C functions within Perl."
msgstr ""

#. type: =head2
#: perlxstut.pod:442
msgid "The TYPEMAP file"
msgstr ""

#. type: textblock
#: perlxstut.pod:444
msgid "The B<xsubpp> program uses rules to convert from Perl's data types (scalar, array, etc.) to C's data types (int, char, etc.).  These rules are stored in the typemap file ($PERLLIB/ExtUtils/typemap).  This file is split into three parts."
msgstr ""

#. type: textblock
#: perlxstut.pod:449
msgid "The first section maps various C data types to a name, which corresponds somewhat with the various Perl types.  The second section contains C code which B<xsubpp> uses to handle input parameters.  The third section contains C code which B<xsubpp> uses to handle output parameters."
msgstr ""

#. type: textblock
#: perlxstut.pod:454
msgid "Let's take a look at a portion of the .c file created for our extension.  The file name is Mytest.c:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:457
#, no-wrap
msgid ""
"\tXS(XS_Mytest_round)\n"
"\t{\n"
"\t    dXSARGS;\n"
"\t    if (items != 1)\n"
"\t\tPerl_croak(aTHX_ \"Usage: Mytest::round(arg)\");\n"
"        PERL_UNUSED_VAR(cv); /* -W */\n"
"\t    {\n"
"\t\tdouble  arg = (double)SvNV(ST(0));\t/* XXXXX */\n"
"\t\tif (arg > 0.0) {\n"
"\t\t\targ = floor(arg + 0.5);\n"
"\t\t} else if (arg < 0.0) {\n"
"\t\t\targ = ceil(arg - 0.5);\n"
"\t\t} else {\n"
"\t\t\targ = 0.0;\n"
"\t\t}\n"
"\t\tsv_setnv(ST(0), (double)arg);\t/* XXXXX */\n"
"        SvSETMAGIC(ST(0));\n"
"\t    }\n"
"\t    XSRETURN_EMPTY;\n"
"\t}\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:478
msgid "Notice the two lines commented with \"XXXXX\".  If you check the first section of the typemap file, you'll see that doubles are of type T_DOUBLE.  In the INPUT section, an argument that is T_DOUBLE is assigned to the variable arg by calling the routine SvNV on something, then casting it to double, then assigned to the variable arg.  Similarly, in the OUTPUT section, once arg has its final value, it is passed to the sv_setnv function to be passed back to the calling subroutine.  These two functions are explained in L<perlguts>; we'll talk more later about what that \"ST(0)\" means in the section on the argument stack."
msgstr ""

#. type: =head2
#: perlxstut.pod:488
msgid "Warning about Output Arguments"
msgstr ""

#. type: textblock
#: perlxstut.pod:490
msgid "In general, it's not a good idea to write extensions that modify their input parameters, as in Example 3.  Instead, you should probably return multiple values in an array and let the caller handle them (we'll do this in a later example).  However, in order to better accommodate calling pre-existing C routines, which often do modify their input parameters, this behavior is tolerated."
msgstr ""

#. type: =head2
#: perlxstut.pod:497
msgid "EXAMPLE 4"
msgstr ""

#. type: textblock
#: perlxstut.pod:499
msgid "In this example, we'll now begin to write XSUBs that will interact with pre-defined C libraries.  To begin with, we will build a small library of our own, then let h2xs write our .pm and .xs files for us."
msgstr ""

#. type: textblock
#: perlxstut.pod:503
msgid "Create a new directory called Mytest2 at the same level as the directory Mytest.  In the Mytest2 directory, create another directory called mylib, and cd into that directory."
msgstr ""

#. type: textblock
#: perlxstut.pod:507
msgid "Here we'll create some files that will generate a test library.  These will include a C source file and a header file.  We'll also create a Makefile.PL in this directory.  Then we'll make sure that running make at the Mytest2 level will automatically run this Makefile.PL file and the resulting Makefile."
msgstr ""

#. type: textblock
#: perlxstut.pod:512
msgid "In the mylib directory, create a file mylib.h that looks like this:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:514
#, no-wrap
msgid ""
"\t#define TESTVAL\t4\n"
"\n"
msgstr ""

#. type: verbatim
#: perlxstut.pod:516
#, no-wrap
msgid ""
"\textern double\tfoo(int, long, const char*);\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:518
msgid "Also create a file mylib.c that looks like this:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:520
#, no-wrap
msgid ""
"\t#include <stdlib.h>\n"
"\t#include \"./mylib.h\"\n"
"\n"
msgstr ""

#. type: verbatim
#: perlxstut.pod:523
#, no-wrap
msgid ""
"\tdouble\n"
"\tfoo(int a, long b, const char *c)\n"
"\t{\n"
"\t\treturn (a + b + atof(c) + TESTVAL);\n"
"\t}\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:529
msgid "And finally create a file Makefile.PL that looks like this:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:531
#, no-wrap
msgid ""
"\tuse ExtUtils::MakeMaker;\n"
"\t$Verbose = 1;\n"
"\tWriteMakefile(\n"
"\t    NAME   => 'Mytest2::mylib',\n"
"\t    SKIP   => [qw(all static static_lib dynamic dynamic_lib)],\n"
"\t    clean  => {'FILES' => 'libmylib$(LIB_EXT)'},\n"
"\t);\n"
"\n"
msgstr ""

#. type: verbatim
#: perlxstut.pod:540
#, no-wrap
msgid ""
"\tsub MY::top_targets {\n"
"\t\t'\n"
"\tall :: static\n"
"\n"
msgstr ""

#. type: verbatim
#: perlxstut.pod:544
#, no-wrap
msgid ""
"\tpure_all :: static\n"
"\n"
msgstr ""

#. type: verbatim
#: perlxstut.pod:546
#, no-wrap
msgid ""
"\tstatic ::       libmylib$(LIB_EXT)\n"
"\n"
msgstr ""

#. type: verbatim
#: perlxstut.pod:548
#, no-wrap
msgid ""
"\tlibmylib$(LIB_EXT): $(O_FILES)\n"
"\t\t$(AR) cr libmylib$(LIB_EXT) $(O_FILES)\n"
"\t\t$(RANLIB) libmylib$(LIB_EXT)\n"
"\n"
msgstr ""

#. type: verbatim
#: perlxstut.pod:552
#, no-wrap
msgid ""
"\t';\n"
"\t}\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:555
msgid "Make sure you use a tab and not spaces on the lines beginning with \"$(AR)\" and \"$(RANLIB)\".  Make will not function properly if you use spaces.  It has also been reported that the \"cr\" argument to $(AR) is unnecessary on Win32 systems."
msgstr ""

#. type: textblock
#: perlxstut.pod:560
msgid "We will now create the main top-level Mytest2 files.  Change to the directory above Mytest2 and run the following command:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:563
#, no-wrap
msgid ""
"\t% h2xs -O -n Mytest2 ./Mytest2/mylib/mylib.h\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:565
msgid "This will print out a warning about overwriting Mytest2, but that's okay.  Our files are stored in Mytest2/mylib, and will be untouched."
msgstr ""

#. type: textblock
#: perlxstut.pod:568
msgid "The normal Makefile.PL that h2xs generates doesn't know about the mylib directory.  We need to tell it that there is a subdirectory and that we will be generating a library in it.  Let's add the argument MYEXTLIB to the WriteMakefile call so that it looks like this:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:573
#, no-wrap
msgid ""
"\tWriteMakefile(\n"
"\t    'NAME'      => 'Mytest2',\n"
"\t    'VERSION_FROM' => 'Mytest2.pm', # finds $VERSION\n"
"\t    'LIBS'      => [''],   # e.g., '-lm'\n"
"\t    'DEFINE'    => '',     # e.g., '-DHAVE_SOMETHING'\n"
"\t    'INC'       => '',     # e.g., '-I/usr/include/other'\n"
"\t    'MYEXTLIB' => 'mylib/libmylib$(LIB_EXT)',\n"
"\t);\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:582
msgid "and then at the end add a subroutine (which will override the pre-existing subroutine).  Remember to use a tab character to indent the line beginning with \"cd\"!"
msgstr ""

#. type: verbatim
#: perlxstut.pod:586
#, no-wrap
msgid ""
"\tsub MY::postamble {\n"
"\t'\n"
"\t$(MYEXTLIB): mylib/Makefile\n"
"\t\tcd mylib && $(MAKE) $(PASSTHRU)\n"
"\t';\n"
"\t}\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:593
msgid "Let's also fix the MANIFEST file so that it accurately reflects the contents of our extension.  The single line that says \"mylib\" should be replaced by the following three lines:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:597
#, no-wrap
msgid ""
"\tmylib/Makefile.PL\n"
"\tmylib/mylib.c\n"
"\tmylib/mylib.h\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:601
msgid "To keep our namespace nice and unpolluted, edit the .pm file and change the variable C<@EXPORT> to C<@EXPORT_OK>.  Finally, in the .xs file, edit the #include line to read:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:605
#, no-wrap
msgid ""
"\t#include \"mylib/mylib.h\"\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:607
msgid "And also add the following function definition to the end of the .xs file:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:609
#: perlxstut.pod:725
#, no-wrap
msgid ""
"\tdouble\n"
"\tfoo(a,b,c)\n"
"\t\tint             a\n"
"\t\tlong            b\n"
"\t\tconst char *    c\n"
"\t    OUTPUT:\n"
"\t\tRETVAL\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:617
msgid "Now we also need to create a typemap file because the default Perl doesn't currently support the const char * type.  Create a file called typemap in the Mytest2 directory and place the following in it:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:621
#, no-wrap
msgid ""
"\tconst char *\tT_PV\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:623
msgid "Now run perl on the top-level Makefile.PL.  Notice that it also created a Makefile in the mylib directory.  Run make and watch that it does cd into the mylib directory and run make in there as well."
msgstr ""

#. type: textblock
#: perlxstut.pod:627
msgid "Now edit the Mytest2.t script and change the number of tests to \"4\", and add the following lines to the end of the script:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:630
#, no-wrap
msgid ""
"\tis( &Mytest2::foo(1, 2, \"Hello, world!\"), 7 );\n"
"\tis( &Mytest2::foo(1, 2, \"0.0\"), 7 );\n"
"\tok( abs(&Mytest2::foo(0, 0, \"-3.4\") - 0.6) <= 0.01 );\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:634
msgid "(When dealing with floating-point comparisons, it is best to not check for equality, but rather that the difference between the expected and actual result is below a certain amount (called epsilon) which is 0.01 in this case)"
msgstr ""

#. type: textblock
#: perlxstut.pod:638
msgid "Run \"C<make test>\" and all should be well. There are some warnings on missing tests for the Mytest2::mylib extension, but you can ignore them."
msgstr ""

#. type: =head2
#: perlxstut.pod:641
msgid "What has happened here?"
msgstr ""

#. type: textblock
#: perlxstut.pod:643
msgid "Unlike previous examples, we've now run h2xs on a real include file.  This has caused some extra goodies to appear in both the .pm and .xs files."
msgstr ""

#. type: textblock
#: perlxstut.pod:650
msgid "In the .xs file, there's now a #include directive with the absolute path to the mylib.h header file.  We changed this to a relative path so that we could move the extension directory if we wanted to."
msgstr ""

#. type: textblock
#: perlxstut.pod:656
msgid "There's now some new C code that's been added to the .xs file.  The purpose of the C<constant> routine is to make the values that are #define'd in the header file accessible by the Perl script (by calling either C<TESTVAL> or C<&Mytest2::TESTVAL>).  There's also some XS code to allow calls to the C<constant> routine."
msgstr ""

#. type: textblock
#: perlxstut.pod:664
msgid "The .pm file originally exported the name C<TESTVAL> in the C<@EXPORT> array.  This could lead to name clashes.  A good rule of thumb is that if the #define is only going to be used by the C routines themselves, and not by the user, they should be removed from the C<@EXPORT> array.  Alternately, if you don't mind using the \"fully qualified name\" of a variable, you could move most or all of the items from the C<@EXPORT> array into the C<@EXPORT_OK> array."
msgstr ""

#. type: textblock
#: perlxstut.pod:673
msgid "If our include file had contained #include directives, these would not have been processed by h2xs.  There is no good solution to this right now."
msgstr ""

#. type: textblock
#: perlxstut.pod:678
msgid "We've also told Perl about the library that we built in the mylib subdirectory.  That required only the addition of the C<MYEXTLIB> variable to the WriteMakefile call and the replacement of the postamble subroutine to cd into the subdirectory and run make.  The Makefile.PL for the library is a bit more complicated, but not excessively so.  Again we replaced the postamble subroutine to insert our own code.  This code simply specified that the library to be created here was a static archive library (as opposed to a dynamically loadable library) and provided the commands to build it."
msgstr ""

#. type: =head2
#: perlxstut.pod:690
msgid "Anatomy of .xs file"
msgstr ""

#. type: textblock
#: perlxstut.pod:692
msgid "The .xs file of L<\"EXAMPLE 4\"> contained some new elements.  To understand the meaning of these elements, pay attention to the line which reads"
msgstr ""

#. type: verbatim
#: perlxstut.pod:695
#, no-wrap
msgid ""
"\tMODULE = Mytest2\t\tPACKAGE = Mytest2\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:697
msgid "Anything before this line is plain C code which describes which headers to include, and defines some convenience functions.  No translations are performed on this part, apart from having embedded POD documentation skipped over (see L<perlpod>) it goes into the generated output C file as is."
msgstr ""

#. type: textblock
#: perlxstut.pod:702
msgid "Anything after this line is the description of XSUB functions.  These descriptions are translated by B<xsubpp> into C code which implements these functions using Perl calling conventions, and which makes these functions visible from Perl interpreter."
msgstr ""

#. type: textblock
#: perlxstut.pod:707
msgid "Pay a special attention to the function C<constant>.  This name appears twice in the generated .xs file: once in the first part, as a static C function, then another time in the second part, when an XSUB interface to this static C function is defined."
msgstr ""

#. type: textblock
#: perlxstut.pod:712
msgid "This is quite typical for .xs files: usually the .xs file provides an interface to an existing C function.  Then this C function is defined somewhere (either in an external library, or in the first part of .xs file), and a Perl interface to this function (i.e. \"Perl glue\") is described in the second part of .xs file.  The situation in L<\"EXAMPLE 1\">, L<\"EXAMPLE 2\">, and L<\"EXAMPLE 3\">, when all the work is done inside the \"Perl glue\", is somewhat of an exception rather than the rule."
msgstr ""

#. type: =head2
#: perlxstut.pod:720
msgid "Getting the fat out of XSUBs"
msgstr ""

#. type: textblock
#: perlxstut.pod:722
msgid "In L<\"EXAMPLE 4\"> the second part of .xs file contained the following description of an XSUB:"
msgstr ""

#. type: textblock
#: perlxstut.pod:733
msgid "Note that in contrast with L<\"EXAMPLE 1\">, L<\"EXAMPLE 2\"> and L<\"EXAMPLE 3\">, this description does not contain the actual I<code> for what is done is done during a call to Perl function foo().  To understand what is going on here, one can add a CODE section to this XSUB:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:738
#, no-wrap
msgid ""
"\tdouble\n"
"\tfoo(a,b,c)\n"
"\t\tint             a\n"
"\t\tlong            b\n"
"\t\tconst char *    c\n"
"\t    CODE:\n"
"\t\tRETVAL = foo(a,b,c);\n"
"\t    OUTPUT:\n"
"\t\tRETVAL\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:748
msgid "However, these two XSUBs provide almost identical generated C code: B<xsubpp> compiler is smart enough to figure out the C<CODE:> section from the first two lines of the description of XSUB.  What about C<OUTPUT:> section? In fact, that is absolutely the same! The C<OUTPUT:> section can be removed as well, I<as far as C<CODE:> section or C<PPCODE:> section> is not specified: B<xsubpp> can see that it needs to generate a function call section, and will autogenerate the OUTPUT section too.  Thus one can shortcut the XSUB to become:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:757
#, no-wrap
msgid ""
"\tdouble\n"
"\tfoo(a,b,c)\n"
"\t\tint             a\n"
"\t\tlong            b\n"
"\t\tconst char *    c\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:763
msgid "Can we do the same with an XSUB"
msgstr ""

#. type: verbatim
#: perlxstut.pod:765
#, no-wrap
msgid ""
"\tint\n"
"\tis_even(input)\n"
"\t\tint\tinput\n"
"\t    CODE:\n"
"\t\tRETVAL = (input % 2 == 0);\n"
"\t    OUTPUT:\n"
"\t\tRETVAL\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:773
msgid "of L<\"EXAMPLE 2\">? To do this, one needs to define a C function C<int is_even(int input)>.  As we saw in L<Anatomy of .xs file>, a proper place for this definition is in the first part of .xs file.  In fact a C function"
msgstr ""

#. type: verbatim
#: perlxstut.pod:777
#, no-wrap
msgid ""
"\tint\n"
"\tis_even(int arg)\n"
"\t{\n"
"\t\treturn (arg % 2 == 0);\n"
"\t}\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:783
msgid "is probably overkill for this.  Something as simple as a C<#define> will do too:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:786
#, no-wrap
msgid ""
"\t#define is_even(arg)\t((arg) % 2 == 0)\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:788
msgid "After having this in the first part of .xs file, the \"Perl glue\" part becomes as simple as"
msgstr ""

#. type: verbatim
#: perlxstut.pod:791
#, no-wrap
msgid ""
"\tint\n"
"\tis_even(input)\n"
"\t\tint\tinput\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:795
msgid "This technique of separation of the glue part from the workhorse part has obvious tradeoffs: if you want to change a Perl interface, you need to change two places in your code.  However, it removes a lot of clutter, and makes the workhorse part independent from idiosyncrasies of Perl calling convention.  (In fact, there is nothing Perl-specific in the above description, a different version of B<xsubpp> might have translated this to TCL glue or Python glue as well.)"
msgstr ""

#. type: =head2
#: perlxstut.pod:803
msgid "More about XSUB arguments"
msgstr ""

#. type: textblock
#: perlxstut.pod:805
msgid "With the completion of Example 4, we now have an easy way to simulate some real-life libraries whose interfaces may not be the cleanest in the world.  We shall now continue with a discussion of the arguments passed to the B<xsubpp> compiler."
msgstr ""

#. type: textblock
#: perlxstut.pod:810
msgid "When you specify arguments to routines in the .xs file, you are really passing three pieces of information for each argument listed.  The first piece is the order of that argument relative to the others (first, second, etc).  The second is the type of argument, and consists of the type declaration of the argument (e.g., int, char*, etc).  The third piece is the calling convention for the argument in the call to the library function."
msgstr ""

#. type: textblock
#: perlxstut.pod:817
msgid "While Perl passes arguments to functions by reference, C passes arguments by value; to implement a C function which modifies data of one of the \"arguments\", the actual argument of this C function would be a pointer to the data.  Thus two C functions with declarations"
msgstr ""

#. type: verbatim
#: perlxstut.pod:822
#, no-wrap
msgid ""
"\tint string_length(char *s);\n"
"\tint upper_case_char(char *cp);\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:825
msgid "may have completely different semantics: the first one may inspect an array of chars pointed by s, and the second one may immediately dereference C<cp> and manipulate C<*cp> only (using the return value as, say, a success indicator).  From Perl one would use these functions in a completely different manner."
msgstr ""

#. type: textblock
#: perlxstut.pod:831
msgid "One conveys this info to B<xsubpp> by replacing C<*> before the argument by C<&>.  C<&> means that the argument should be passed to a library function by its address.  The above two function may be XSUB-ified as"
msgstr ""

#. type: verbatim
#: perlxstut.pod:835
#, no-wrap
msgid ""
"\tint\n"
"\tstring_length(s)\n"
"\t\tchar *\ts\n"
"\n"
msgstr ""

#. type: verbatim
#: perlxstut.pod:839
#, no-wrap
msgid ""
"\tint\n"
"\tupper_case_char(cp)\n"
"\t\tchar\t&cp\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:843
msgid "For example, consider:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:845
#, no-wrap
msgid ""
"\tint\n"
"\tfoo(a,b)\n"
"\t\tchar\t&a\n"
"\t\tchar *\tb\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:850
msgid "The first Perl argument to this function would be treated as a char and assigned to the variable a, and its address would be passed into the function foo.  The second Perl argument would be treated as a string pointer and assigned to the variable b.  The I<value> of b would be passed into the function foo.  The actual call to the function foo that B<xsubpp> generates would look like this:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:856
#, no-wrap
msgid ""
"\tfoo(&a, b);\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:858
msgid "B<xsubpp> will parse the following function argument lists identically:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:860
#, no-wrap
msgid ""
"\tchar\t&a\n"
"\tchar&a\n"
"\tchar\t& a\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:864
msgid "However, to help ease understanding, it is suggested that you place a \"&\" next to the variable name and away from the variable type), and place a \"*\" near the variable type, but away from the variable name (as in the call to foo above).  By doing so, it is easy to understand exactly what will be passed to the C function; it will be whatever is in the \"last column\"."
msgstr ""

#. type: textblock
#: perlxstut.pod:871
msgid "You should take great pains to try to pass the function the type of variable it wants, when possible.  It will save you a lot of trouble in the long run."
msgstr ""

#. type: =head2
#: perlxstut.pod:874
msgid "The Argument Stack"
msgstr ""

#. type: textblock
#: perlxstut.pod:876
msgid "If we look at any of the C code generated by any of the examples except example 1, you will notice a number of references to ST(n), where n is usually 0.  \"ST\" is actually a macro that points to the n'th argument on the argument stack.  ST(0) is thus the first argument on the stack and therefore the first argument passed to the XSUB, ST(1) is the second argument, and so on."
msgstr ""

#. type: textblock
#: perlxstut.pod:883
msgid "When you list the arguments to the XSUB in the .xs file, that tells B<xsubpp> which argument corresponds to which of the argument stack (i.e., the first one listed is the first argument, and so on).  You invite disaster if you do not list them in the same order as the function expects them."
msgstr ""

#. type: textblock
#: perlxstut.pod:888
msgid "The actual values on the argument stack are pointers to the values passed in.  When an argument is listed as being an OUTPUT value, its corresponding value on the stack (i.e., ST(0) if it was the first argument) is changed.  You can verify this by looking at the C code generated for Example 3.  The code for the round() XSUB routine contains lines that look like this:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:894
#, no-wrap
msgid ""
"\tdouble  arg = (double)SvNV(ST(0));\n"
"\t/* Round the contents of the variable arg */\n"
"\tsv_setnv(ST(0), (double)arg);\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:898
msgid "The arg variable is initially set by taking the value from ST(0), then is stored back into ST(0) at the end of the routine."
msgstr ""

#. type: textblock
#: perlxstut.pod:901
msgid "XSUBs are also allowed to return lists, not just scalars.  This must be done by manipulating stack values ST(0), ST(1), etc, in a subtly different way.  See L<perlxs> for details."
msgstr ""

#. type: textblock
#: perlxstut.pod:905
msgid "XSUBs are also allowed to avoid automatic conversion of Perl function arguments to C function arguments.  See L<perlxs> for details.  Some people prefer manual conversion by inspecting C<ST(i)> even in the cases when automatic conversion will do, arguing that this makes the logic of an XSUB call clearer.  Compare with L<\"Getting the fat out of XSUBs\"> for a similar tradeoff of a complete separation of \"Perl glue\" and \"workhorse\" parts of an XSUB."
msgstr ""

#. type: textblock
#: perlxstut.pod:912
msgid "While experts may argue about these idioms, a novice to Perl guts may prefer a way which is as little Perl-guts-specific as possible, meaning automatic conversion and automatic call generation, as in L<\"Getting the fat out of XSUBs\">.  This approach has the additional benefit of protecting the XSUB writer from future changes to the Perl API."
msgstr ""

#. type: =head2
#: perlxstut.pod:918
msgid "Extending your Extension"
msgstr ""

#. type: textblock
#: perlxstut.pod:920
msgid "Sometimes you might want to provide some extra methods or subroutines to assist in making the interface between Perl and your extension simpler or easier to understand.  These routines should live in the .pm file.  Whether they are automatically loaded when the extension itself is loaded or only loaded when called depends on where in the .pm file the subroutine definition is placed.  You can also consult L<AutoLoader> for an alternate way to store and load your extra subroutines."
msgstr ""

#. type: =head2
#: perlxstut.pod:928
msgid "Documenting your Extension"
msgstr ""

#. type: textblock
#: perlxstut.pod:930
msgid "There is absolutely no excuse for not documenting your extension.  Documentation belongs in the .pm file.  This file will be fed to pod2man, and the embedded documentation will be converted to the manpage format, then placed in the blib directory.  It will be copied to Perl's manpage directory when the extension is installed."
msgstr ""

#. type: textblock
#: perlxstut.pod:936
msgid "You may intersperse documentation and Perl code within the .pm file.  In fact, if you want to use method autoloading, you must do this, as the comment inside the .pm file explains."
msgstr ""

#. type: textblock
#: perlxstut.pod:940
msgid "See L<perlpod> for more information about the pod format."
msgstr ""

#. type: =head2
#: perlxstut.pod:942
msgid "Installing your Extension"
msgstr ""

#. type: textblock
#: perlxstut.pod:944
msgid "Once your extension is complete and passes all its tests, installing it is quite simple: you simply run \"make install\".  You will either need to have write permission into the directories where Perl is installed, or ask your system administrator to run the make for you."
msgstr ""

#. type: textblock
#: perlxstut.pod:949
msgid "Alternately, you can specify the exact directory to place the extension's files by placing a \"PREFIX=/destination/directory\" after the make install.  (or in between the make and install if you have a brain-dead version of make).  This can be very useful if you are building an extension that will eventually be distributed to multiple systems.  You can then just archive the files in the destination directory and distribute them to your destination systems."
msgstr ""

#. type: =head2
#: perlxstut.pod:956
msgid "EXAMPLE 5"
msgstr ""

#. type: textblock
#: perlxstut.pod:958
msgid "In this example, we'll do some more work with the argument stack.  The previous examples have all returned only a single value.  We'll now create an extension that returns an array."
msgstr ""

#. type: textblock
#: perlxstut.pod:962
msgid "This extension is very Unix-oriented (struct statfs and the statfs system call).  If you are not running on a Unix system, you can substitute for statfs any other function that returns multiple values, you can hard-code values to be returned to the caller (although this will be a bit harder to test the error case), or you can simply not do this example.  If you change the XSUB, be sure to fix the test cases to match the changes."
msgstr ""

#. type: textblock
#: perlxstut.pod:969
#: perlxstut.pod:1085
msgid "Return to the Mytest directory and add the following code to the end of Mytest.xs:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:972
#, no-wrap
msgid ""
"\tvoid\n"
"\tstatfs(path)\n"
"\t\tchar *  path\n"
"\t    INIT:\n"
"\t\tint i;\n"
"\t\tstruct statfs buf;\n"
"\n"
msgstr ""

#. type: verbatim
#: perlxstut.pod:979
#, no-wrap
msgid ""
"\t    PPCODE:\n"
"\t\ti = statfs(path, &buf);\n"
"\t\tif (i == 0) {\n"
"\t\t\tXPUSHs(sv_2mortal(newSVnv(buf.f_bavail)));\n"
"\t\t\tXPUSHs(sv_2mortal(newSVnv(buf.f_bfree)));\n"
"\t\t\tXPUSHs(sv_2mortal(newSVnv(buf.f_blocks)));\n"
"\t\t\tXPUSHs(sv_2mortal(newSVnv(buf.f_bsize)));\n"
"\t\t\tXPUSHs(sv_2mortal(newSVnv(buf.f_ffree)));\n"
"\t\t\tXPUSHs(sv_2mortal(newSVnv(buf.f_files)));\n"
"\t\t\tXPUSHs(sv_2mortal(newSVnv(buf.f_type)));\n"
"\t\t} else {\n"
"\t\t\tXPUSHs(sv_2mortal(newSVnv(errno)));\n"
"\t\t}\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:993
msgid "You'll also need to add the following code to the top of the .xs file, just after the include of \"XSUB.h\":"
msgstr ""

#. type: verbatim
#: perlxstut.pod:996
#, no-wrap
msgid ""
"\t#include <sys/vfs.h>\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:998
msgid "Also add the following code segment to Mytest.t while incrementing the \"9\" tests to \"11\":"
msgstr ""

#. type: verbatim
#: perlxstut.pod:1001
#, no-wrap
msgid ""
"\t@a = &Mytest::statfs(\"/blech\");\n"
"\tok( scalar(@a) == 1 && $a[0] == 2 );\n"
"\t@a = &Mytest::statfs(\"/\");\n"
"\tis( scalar(@a), 7 );\n"
"\n"
msgstr ""

#. type: =head2
#: perlxstut.pod:1006
#: perlxstut.pod:1139
msgid "New Things in this Example"
msgstr ""

#. type: textblock
#: perlxstut.pod:1008
msgid "This example added quite a few new concepts.  We'll take them one at a time."
msgstr ""

#. type: textblock
#: perlxstut.pod:1014
msgid "The INIT: directive contains code that will be placed immediately after the argument stack is decoded.  C does not allow variable declarations at arbitrary locations inside a function, so this is usually the best way to declare local variables needed by the XSUB.  (Alternatively, one could put the whole C<PPCODE:> section into braces, and put these declarations on top.)"
msgstr ""

#. type: textblock
#: perlxstut.pod:1023
msgid "This routine also returns a different number of arguments depending on the success or failure of the call to statfs.  If there is an error, the error number is returned as a single-element array.  If the call is successful, then a 9-element array is returned.  Since only one argument is passed into this function, we need room on the stack to hold the 9 values which may be returned."
msgstr ""

#. type: textblock
#: perlxstut.pod:1030
msgid "We do this by using the PPCODE: directive, rather than the CODE: directive.  This tells B<xsubpp> that we will be managing the return values that will be put on the argument stack by ourselves."
msgstr ""

#. type: textblock
#: perlxstut.pod:1036
msgid "When we want to place values to be returned to the caller onto the stack, we use the series of macros that begin with \"XPUSH\".  There are five different versions, for placing integers, unsigned integers, doubles, strings, and Perl scalars on the stack.  In our example, we placed a Perl scalar onto the stack.  (In fact this is the only macro which can be used to return multiple values.)"
msgstr ""

#. type: textblock
#: perlxstut.pod:1043
msgid "The XPUSH* macros will automatically extend the return stack to prevent it from being overrun.  You push values onto the stack in the order you want them seen by the calling program."
msgstr ""

#. type: textblock
#: perlxstut.pod:1049
msgid "The values pushed onto the return stack of the XSUB are actually mortal SV's.  They are made mortal so that once the values are copied by the calling program, the SV's that held the returned values can be deallocated.  If they were not mortal, then they would continue to exist after the XSUB routine returned, but would not be accessible.  This is a memory leak."
msgstr ""

#. type: textblock
#: perlxstut.pod:1057
msgid "If we were interested in performance, not in code compactness, in the success branch we would not use C<XPUSHs> macros, but C<PUSHs> macros, and would pre-extend the stack before pushing the return values:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:1061
#, no-wrap
msgid ""
"\tEXTEND(SP, 7);\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:1063
msgid "The tradeoff is that one needs to calculate the number of return values in advance (though overextending the stack will not typically hurt anything but memory consumption)."
msgstr ""

#. type: textblock
#: perlxstut.pod:1067
msgid "Similarly, in the failure branch we could use C<PUSHs> I<without> extending the stack: the Perl function reference comes to an XSUB on the stack, thus the stack is I<always> large enough to take one return value."
msgstr ""

#. type: =head2
#: perlxstut.pod:1073
msgid "EXAMPLE 6"
msgstr ""

#. type: textblock
#: perlxstut.pod:1075
msgid "In this example, we will accept a reference to an array as an input parameter, and return a reference to an array of hashes.  This will demonstrate manipulation of complex Perl data types from an XSUB."
msgstr ""

#. type: textblock
#: perlxstut.pod:1079
msgid "This extension is somewhat contrived.  It is based on the code in the previous example.  It calls the statfs function multiple times, accepting a reference to an array of filenames as input, and returning a reference to an array of hashes containing the data for each of the filesystems."
msgstr ""

#. type: verbatim
#: perlxstut.pod:1088
#, no-wrap
msgid ""
"    SV *\n"
"    multi_statfs(paths)\n"
"\t    SV * paths\n"
"\tINIT:\n"
"\t    AV * results;\n"
"\t    I32 numpaths = 0;\n"
"\t    int i, n;\n"
"\t    struct statfs buf;\n"
"\n"
msgstr ""

#. type: verbatim
#: perlxstut.pod:1097
#, no-wrap
msgid ""
"\t    if ((!SvROK(paths))\n"
"\t\t|| (SvTYPE(SvRV(paths)) != SVt_PVAV)\n"
"\t\t|| ((numpaths = av_len((AV *)SvRV(paths))) < 0))\n"
"\t    {\n"
"\t\tXSRETURN_UNDEF;\n"
"\t    }\n"
"\t    results = (AV *)sv_2mortal((SV *)newAV());\n"
"\tCODE:\n"
"\t    for (n = 0; n <= numpaths; n++) {\n"
"\t\tHV * rh;\n"
"\t\tSTRLEN l;\n"
"\t\tchar * fn = SvPV(*av_fetch((AV *)SvRV(paths), n, 0), l);\n"
"\n"
msgstr ""

#. type: verbatim
#: perlxstut.pod:1110
#, no-wrap
msgid ""
"\t\ti = statfs(fn, &buf);\n"
"\t\tif (i != 0) {\n"
"\t\t    av_push(results, newSVnv(errno));\n"
"\t\t    continue;\n"
"\t\t}\n"
"\n"
msgstr ""

#. type: verbatim
#: perlxstut.pod:1116
#, no-wrap
msgid ""
"\t\trh = (HV *)sv_2mortal((SV *)newHV());\n"
"\n"
msgstr ""

#. type: verbatim
#: perlxstut.pod:1118
#, no-wrap
msgid ""
"\t\thv_store(rh, \"f_bavail\", 8, newSVnv(buf.f_bavail), 0);\n"
"\t\thv_store(rh, \"f_bfree\",  7, newSVnv(buf.f_bfree),  0);\n"
"\t\thv_store(rh, \"f_blocks\", 8, newSVnv(buf.f_blocks), 0);\n"
"\t\thv_store(rh, \"f_bsize\",  7, newSVnv(buf.f_bsize),  0);\n"
"\t\thv_store(rh, \"f_ffree\",  7, newSVnv(buf.f_ffree),  0);\n"
"\t\thv_store(rh, \"f_files\",  7, newSVnv(buf.f_files),  0);\n"
"\t\thv_store(rh, \"f_type\",   6, newSVnv(buf.f_type),   0);\n"
"\n"
msgstr ""

#. type: verbatim
#: perlxstut.pod:1126
#, no-wrap
msgid ""
"\t\tav_push(results, newRV((SV *)rh));\n"
"\t    }\n"
"\t    RETVAL = newRV((SV *)results);\n"
"\tOUTPUT:\n"
"\t    RETVAL\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:1132
msgid "And add the following code to Mytest.t, while incrementing the \"11\" tests to \"13\":"
msgstr ""

#. type: verbatim
#: perlxstut.pod:1135
#, no-wrap
msgid ""
"\t$results = Mytest::multi_statfs([ '/', '/blech' ]);\n"
"\tok( ref $results->[0]) );\n"
"\tok( ! ref $results->[1] );\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:1141
msgid "There are a number of new concepts introduced here, described below:"
msgstr ""

#. type: textblock
#: perlxstut.pod:1147
msgid "This function does not use a typemap.  Instead, we declare it as accepting one SV* (scalar) parameter, and returning an SV* value, and we take care of populating these scalars within the code.  Because we are only returning one value, we don't need a C<PPCODE:> directive - instead, we use C<CODE:> and C<OUTPUT:> directives."
msgstr ""

#. type: textblock
#: perlxstut.pod:1155
msgid "When dealing with references, it is important to handle them with caution.  The C<INIT:> block first checks that C<SvROK> returns true, which indicates that paths is a valid reference.  It then verifies that the object referenced by paths is an array, using C<SvRV> to dereference paths, and C<SvTYPE> to discover its type.  As an added test, it checks that the array referenced by paths is non-empty, using the C<av_len> function (which returns -1 if the array is empty).  The XSRETURN_UNDEF macro is used to abort the XSUB and return the undefined value whenever all three of these conditions are not met."
msgstr ""

#. type: textblock
#: perlxstut.pod:1167
msgid "We manipulate several arrays in this XSUB.  Note that an array is represented internally by an AV* pointer.  The functions and macros for manipulating arrays are similar to the functions in Perl: C<av_len> returns the highest index in an AV*, much like $#array; C<av_fetch> fetches a single scalar value from an array, given its index; C<av_push> pushes a scalar value onto the end of the array, automatically extending the array as necessary."
msgstr ""

#. type: textblock
#: perlxstut.pod:1174
msgid "Specifically, we read pathnames one at a time from the input array, and store the results in an output array (results) in the same order.  If statfs fails, the element pushed onto the return array is the value of errno after the failure.  If statfs succeeds, though, the value pushed onto the return array is a reference to a hash containing some of the information in the statfs structure."
msgstr ""

#. type: textblock
#: perlxstut.pod:1181
msgid "As with the return stack, it would be possible (and a small performance win)  to pre-extend the return array before pushing data into it, since we know how many elements we will return:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:1185
#, no-wrap
msgid ""
"\tav_extend(results, numpaths);\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:1189
msgid "We are performing only one hash operation in this function, which is storing a new scalar under a key using C<hv_store>.  A hash is represented by an HV* pointer.  Like arrays, the functions for manipulating hashes from an XSUB mirror the functionality available from Perl.  See L<perlguts> and L<perlapi> for details."
msgstr ""

#. type: textblock
#: perlxstut.pod:1197
msgid "To create a reference, we use the C<newRV> function.  Note that you can cast an AV* or an HV* to type SV* in this case (and many others).  This allows you to take references to arrays, hashes and scalars with the same function.  Conversely, the C<SvRV> function always returns an SV*, which may need to be cast to the appropriate type if it is something other than a scalar (check with C<SvTYPE>)."
msgstr ""

#. type: textblock
#: perlxstut.pod:1206
msgid "At this point, xsubpp is doing very little work - the differences between Mytest.xs and Mytest.c are minimal."
msgstr ""

#. type: =head2
#: perlxstut.pod:1211
msgid "EXAMPLE 7 (Coming Soon)"
msgstr ""

#. type: textblock
#: perlxstut.pod:1213
msgid "XPUSH args AND set RETVAL AND assign return value to array"
msgstr ""

#. type: =head2
#: perlxstut.pod:1215
msgid "EXAMPLE 8 (Coming Soon)"
msgstr ""

#. type: textblock
#: perlxstut.pod:1217
msgid "Setting $!"
msgstr ""

#. type: =head2
#: perlxstut.pod:1219
msgid "EXAMPLE 9 Passing open files to XSes"
msgstr ""

#. type: textblock
#: perlxstut.pod:1221
msgid "You would think passing files to an XS is difficult, with all the typeglobs and stuff. Well, it isn't."
msgstr ""

#. type: textblock
#: perlxstut.pod:1224
msgid "Suppose that for some strange reason we need a wrapper around the standard C library function C<fputs()>. This is all we need:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:1227
#, no-wrap
msgid ""
"\t#define PERLIO_NOT_STDIO 0\n"
"\t#include \"EXTERN.h\"\n"
"\t#include \"perl.h\"\n"
"\t#include \"XSUB.h\"\n"
"\n"
msgstr ""

#. type: verbatim
#: perlxstut.pod:1232
#, no-wrap
msgid ""
"\t#include <stdio.h>\n"
"\n"
msgstr ""

#. type: verbatim
#: perlxstut.pod:1234
#, no-wrap
msgid ""
"\tint\n"
"\tfputs(s, stream)\n"
"\t\tchar *          s\n"
"\t\tFILE *\t        stream\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:1239
msgid "The real work is done in the standard typemap."
msgstr ""

#. type: textblock
#: perlxstut.pod:1241
msgid "B<But> you loose all the fine stuff done by the perlio layers. This calls the stdio function C<fputs()>, which knows nothing about them."
msgstr ""

#. type: textblock
#: perlxstut.pod:1244
msgid "The standard typemap offers three variants of PerlIO *: C<InputStream> (T_IN), C<InOutStream> (T_INOUT) and C<OutputStream> (T_OUT). A bare C<PerlIO *> is considered a T_INOUT. If it matters in your code (see below for why it might) #define or typedef one of the specific names and use that as the argument or result type in your XS file."
msgstr ""

#. type: textblock
#: perlxstut.pod:1251
msgid "The standard typemap does not contain PerlIO * before perl 5.7, but it has the three stream variants. Using a PerlIO * directly is not backwards compatible unless you provide your own typemap."
msgstr ""

#. type: textblock
#: perlxstut.pod:1255
msgid "For streams coming I<from> perl the main difference is that C<OutputStream> will get the output PerlIO * - which may make a difference on a socket. Like in our example..."
msgstr ""

#. type: textblock
#: perlxstut.pod:1259
msgid "For streams being handed I<to> perl a new file handle is created (i.e. a reference to a new glob) and associated with the PerlIO * provided. If the read/write state of the PerlIO * is not correct then you may get errors or warnings from when the file handle is used.  So if you opened the PerlIO * as \"w\" it should really be an C<OutputStream> if open as \"r\" it should be an C<InputStream>."
msgstr ""

#. type: textblock
#: perlxstut.pod:1266
msgid "Now, suppose you want to use perlio layers in your XS. We'll use the perlio C<PerlIO_puts()> function as an example."
msgstr ""

#. type: textblock
#: perlxstut.pod:1269
msgid "In the C part of the XS file (above the first MODULE line) you have"
msgstr ""

#. type: verbatim
#: perlxstut.pod:1272
#, no-wrap
msgid ""
"\t#define OutputStream\tPerlIO *\n"
"    or\n"
"\ttypedef PerlIO *\tOutputStream;\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:1277
msgid "And this is the XS code:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:1279
#, no-wrap
msgid ""
"\tint\n"
"\tperlioputs(s, stream)\n"
"\t\tchar *          s\n"
"\t\tOutputStream\tstream\n"
"\tCODE:\n"
"\t\tRETVAL = PerlIO_puts(stream, s);\n"
"\tOUTPUT:\n"
"\t\tRETVAL\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:1288
msgid "We have to use a C<CODE> section because C<PerlIO_puts()> has the arguments reversed compared to C<fputs()>, and we want to keep the arguments the same."
msgstr ""

#. type: textblock
#: perlxstut.pod:1291
msgid "Wanting to explore this thoroughly, we want to use the stdio C<fputs()> on a PerlIO *. This means we have to ask the perlio system for a stdio C<FILE *>:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:1295
#, no-wrap
msgid ""
"\tint\n"
"\tperliofputs(s, stream)\n"
"\t\tchar *          s\n"
"\t\tOutputStream\tstream\n"
"\tPREINIT:\n"
"\t\tFILE *fp = PerlIO_findFILE(stream);\n"
"\tCODE:\n"
"\t\tif (fp != (FILE*) 0) {\n"
"\t\t\tRETVAL = fputs(s, fp);\n"
"\t\t} else {\n"
"\t\t\tRETVAL = -1;\n"
"\t\t}\n"
"\tOUTPUT:\n"
"\t\tRETVAL\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:1310
msgid "Note: C<PerlIO_findFILE()> will search the layers for a stdio layer. If it can't find one, it will call C<PerlIO_exportFILE()> to generate a new stdio C<FILE>. Please only call C<PerlIO_exportFILE()> if you want a I<new> C<FILE>. It will generate one on each call and push a new stdio layer. So don't call it repeatedly on the same file. C<PerlIO()>_findFILE will retrieve the stdio layer once it has been generated by C<PerlIO_exportFILE()>."
msgstr ""

#. type: textblock
#: perlxstut.pod:1318
msgid "This applies to the perlio system only. For versions before 5.7, C<PerlIO_exportFILE()> is equivalent to C<PerlIO_findFILE()>."
msgstr ""

#. type: =head2
#: perlxstut.pod:1321
msgid "Troubleshooting these Examples"
msgstr ""

#. type: textblock
#: perlxstut.pod:1323
msgid "As mentioned at the top of this document, if you are having problems with these example extensions, you might see if any of these help you."
msgstr ""

#. type: textblock
#: perlxstut.pod:1330
msgid "In versions of 5.002 prior to the gamma version, the test script in Example 1 will not function properly.  You need to change the \"use lib\" line to read:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:1334
#: perlxstut.pod:1343
#, no-wrap
msgid ""
"\tuse lib './blib';\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:1338
msgid "In versions of 5.002 prior to version 5.002b1h, the test.pl file was not automatically created by h2xs.  This means that you cannot say \"make test\" to run the test script.  You will need to add the following line before the \"use extension\" statement:"
msgstr ""

#. type: textblock
#: perlxstut.pod:1347
msgid "In versions 5.000 and 5.001, instead of using the above line, you will need to use the following line:"
msgstr ""

#. type: verbatim
#: perlxstut.pod:1350
#, no-wrap
msgid ""
"\tBEGIN { unshift(@INC, \"./blib\") }\n"
"\n"
msgstr ""

#. type: textblock
#: perlxstut.pod:1354
msgid "This document assumes that the executable named \"perl\" is Perl version 5.  Some systems may have installed Perl version 5 as \"perl5\"."
msgstr ""

#. type: =head1
#: perlxstut.pod:1359
msgid "See also"
msgstr ""

#. type: textblock
#: perlxstut.pod:1361
msgid "For more information, consult L<perlguts>, L<perlapi>, L<perlxs>, L<perlmod>, and L<perlpod>."
msgstr ""

#. type: =head1
#: perlxstut.pod:1364
msgid "Author"
msgstr ""

#. type: textblock
#: perlxstut.pod:1366
msgid "Jeff Okamoto <F<okamoto@corp.hp.com>>"
msgstr ""

#. type: textblock
#: perlxstut.pod:1368
msgid "Reviewed and assisted by Dean Roehrich, Ilya Zakharevich, Andreas Koenig, and Tim Bunce."
msgstr ""

#. type: textblock
#: perlxstut.pod:1371
msgid "PerlIO material contributed by Lupe Christoph, with some clarification by Nick Ing-Simmons."
msgstr ""

#. type: textblock
#: perlxstut.pod:1374
msgid "Changes for h2xs as of Perl 5.8.x by Renee Baecker"
msgstr ""

#. type: =head2
#: perlxstut.pod:1376
msgid "Last Changed"
msgstr ""

#. type: textblock
#: perlxstut.pod:1378
msgid "2007/10/11"
msgstr ""

